<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="mining.ico">
    <title>Mineral Madness</title>
</head>

<body>
    <div id="motc">
        <h1>Mineral Madness</h1>
        <!-- <p style="font-size: 0.85vw; color: red;" id="motcu">"U" before a version means it is unstable and/or unusable, while the number after the "U" tells you what is the current unstable build of that version*</p> -->
        <h3 id="motctitle" style="line-height: 6px; font-size: 16px">MOTC<!-- <divisor style="color: red">U4*</divisor> --> 0.5
        </h3>
        <p id="motctext1" style="line-height: 4px; font-size: 12px">structure generation has been added and some new biomes</p>
        <p id="motctext2" style="line-height: 4px; font-size: 12px;">use recipes to see a list of recipes</p>
        <p id="motctext3" style="font-size: 12px; line-height: 4px;">0.6 will add simple automation at the price of a few (10-15) coins per minute</p>
        <p id="motctext4" style="line-height: 4px; font-size: 12px;">villages exist and give 1.5x the recourses at the cost of 1.25x the amount you mined in coins, so 1.25 coins a second for 1.5x the resources</p>
        <!-- <p style="color: red; font-size: 12px; line-height: 1px;" id="motcutext1">recipes command exists</p>
        <p style="color: red; font-size: 12px; line-height: 1px;" id="motcutext2">crafting is fixed but perks from tools dont exist yet</p>
        <p style="color: red; font-size: 12px; line-height: 1px;" id="motcutext3">there is now a cool looking submit button for mobile and stuff as well as a better looking input</p> -->
    </div>
    <div id="console">
        <p id="console1" class="consoletext">></p>
        <p id="console2" class="consoletext">></p>
        <p id="console3" class="consoletext">></p>
        <p id="console4" class="consoletext">></p>
        <p id="console5" class="consoletext">></p>
        <p id="console6" class="consoletext">></p>
        <p id="console7" class="consoletext">></p>
        <p id="console8" class="consoletext">></p>
        <p id="console9" class="consoletext">></p>
        <p id="console10" class="consoletext">></p>
        <p id="console11" class="consoletext">></p>
        <input type="text" id="consoleinput" style=" color: white; border-style: solid; border-color: black;">
        <button id="submit">Submit</button>
    </div>
    <div id="consolee">
        <p id="consolee1" class="consoleetext">></p>
        <p id="consolee2" class="consoleetext">></p>
        <p id="consolee3" class="consoleetext">></p>
        <p id="consolee4" class="consoleetext">></p>
        <p id="consolee5" class="consoleetext">></p>
        <p id="consolee6" class="consoleetext">></p>
        <p id="consolee7" class="consoleetext">></p>
        <p id="consolee8" class="consoleetext">></p>
        <p id="consolee9" class="consoleetext">></p>
        <p id="consolee10" class="consoleetext">></p>
    </div>
    <!-- utility scripts -->
    <div>
        <!-- classes -->
        <script>
            class Vector2 {
                /** @param {Number} x @param {Number} y @param {Number} rotation */
                constructor(x, y, rotation) {
                    this.x = x;
                    this.y = y;
                    this.rotation = rotation % 360;
                }
                /** @param {Vector2[]} vectors */
                static addVectors(vectors) {
                    let sumx = 0;
                    let sumy = 0;
                    let sumr = 0;
                    for (let i = 0; i < vectors.length; i++) {
                        sumx += vectors[i].x;
                        sumy += vectors[i].y;
                        sumr += vectors[i].rotation;
                    }
                    return new Vector2(sumx, sumy, sumr);
                }
                /** @param {Vector2[]} vectors */
                static subtractVectors(vectors) {
                    let diffx = 0;
                    let diffy = 0;
                    let diffr = 0;
                    for (let i = 0; i < vectors.length; i++) {
                        diffx -= vectors[i].x;
                        diffy -= vectors[i].y;
                        diffr -= vectors[i].rotation
                    }
                    return new Vector2(diffx, diffy, diffr);
                }
            }
            class NumberRange {
                /** @param {Number} min @param {Number} max */
                constructor(min, max, inclusiveMin, inclusiveMax) {
                    this.min = min;
                    this.max = max;
                    this.inclusiveMax = inclusiveMax;
                    this.inclusiveMin = inclusiveMin;
                }
                /** @param {Number} number @param {Number} offsetMin @param {Number} offsetMax */
                betweenRange(number, offsetMin, offsetMax) {
                    let withinRange = true;
                    if (this.inclusivemin) {
                        if (number < this.min + offsetMin) {
                            withinRange = false;
                        }
                    }
                    else {
                        if (number <= this.min + offsetMin) {
                            withinRange = false;
                        }
                    }
                    if (this.inclusiveMax) {
                        if (number > this.max + offsetMin) {
                            withinRange = false;
                        }
                    }
                    else {
                        if (number >= this.max + offsetMin) {
                            withinRange = false;
                        }
                    }
                }
                /** @param {Number} offsetMin @param {Number} offsetMax */
                randomWithinRange(offsetMin, offsetMax) {
                    return randomNumber(this.min + offsetMin, this.max + offsetMax);
                }
                /** @param {NumberRange} range @param {Number} number @param {Boolean} inclusiveMin @param {Boolean} inclusiveMax    */
                static betweenRange(range, number = 0, inclusiveMin = true, inclusiveMax = true) {
                    let withinRange = true;
                    if (inclusiveMin) {
                        if (number < range.min) {
                            withinRange = false;
                        }
                    }
                    else {
                        if (number <= range.min) {
                            withinRange = false;
                        }
                    }
                    if (inclusiveMax) {
                        if (number > range.max) {
                            withinRange = false;
                        }
                    }
                    else {
                        if (number >= range.max) {
                            withinRange = false;
                        }
                    }
                    return withinRange;
                }
            }
            class Item {
                /** @param {Number} itemVolume @param {String} itemName @param {Number} cost */
                constructor(itemVolume, itemName, cost) {
                    this.volume = itemVolume;
                    this.name = itemName;
                    this.sellValue = cost;
                }
                /** @param {Number} amount */
                inventoryPush(amount) {
                    playerData.inventory.addItem(this.name, amount);
                }
            }
            class MapComponent {
                /** @param {Number} x @param {Number} y */
                constructor(x, y) {
                    this.coordinates = new Vector2(x, y);
                }
                /** @param {Number} x @param {Number} y */
                shiftLocation(x, y) {
                    this.coordinates.x += x;
                    this.coordinates.y += y;
                }
            }
            class Material extends Item {
                /** @param {Number} materialVolume @param {String} materialName @param {Number} basePrevalence @param {String[]} biomes @param {Number} cost*/
                constructor(materialVolume, materialName, basePrevalence, biomes = ['all'], cost) {
                    super(materialVolume, materialName, cost);
                    this.basePrevalence = basePrevalence;
                    this.biomes = biomes;
                }
            }
            //materials
            const MATERIALS_1 = [
                new Material(2, 'stone', 2, undefined, 1),
                new Material(1, 'wood', 2, ['plains', 'forest', 'desert', 'mountain', 'savannah', 'tropical forest'], 1),
                new Material(1, 'clay', 1, ['plains', 'forest', 'savannah', 'tropical forest'], 1),
                new Material(1, 'plants', 2, ['plains', 'forest', 'savannah', 'tropical forest'], 1),
                new Material(2, 'obsidian', 1, ['volcano'], 10),
                new Material(1, 'hide', 1, ['plains', 'forest', 'savannah', 'tropical forest'], 2)
            ];
            class CraftableItem extends Item {
                /** @param {Number} itemVolume @param {String} itemName @param {Object[]} costs @param {String} costs[].item @param {Number} costs[].amount @param {Number} multiplier @param {Number} sellValue*/
                constructor(itemVolume, itemName, costs, multiplier = 1, sellValue/*, tier */) {
                    super(itemVolume, itemName, sellValue);
                    this.costs = costs;
                    this.craftMultiplier = multiplier;
                    //this.craftingTier = tier;
                }
            }
            class Tool extends CraftableItem {
                #hasBeenUsed = false;
                /** @param {Number} toolVolume @param {String} toolName @param {Object[]} costs @param {String} costs[].item @param {Number} costs[].amount @param {Object} miningPerks @param {Number} miningPerks.speed @param {Number} miningPerks.returns @param {Number} miningPerks.tier*/
                constructor(toolVolume, toolName, costs, miningPerks, sellValue) {
                    super(toolVolume, toolName, costs, 1, sellValue);
                    this.perks = {
                        mining: miningPerks,
                    }
                }
                perksPush() {
                    this.#hasBeenUsed = true;
                    playerData.perks.mining.returns *= this.perks.mining.returns;
                    playerData.perks.mining.speed *= this.perks.mining.speed;
                    playerData.perks.mining.tier = this.perks.mining.tier > playerData.perks.mining.speed ? this.perks.mining.tier : playerData.perks.mining.tier;
                    playerData.perks.mining.returns = playerData.perks.mining.returns.toPrecision(2);
                    playerData.perks.mining.speed = playerData.perks.mining.speed.toPrecision(2);
                }
                isUsed() {
                    return this.#hasBeenUsed;
                }
            }
            class MapTile extends MapComponent {
                /** @param {Number} x @param {Number} y @param {String} biome @param {Number[]} prevalenceOffset @param {Number} sizeX @param {Number} sizeY */
                constructor(x = 0, y = 0, biome, prevalenceOffset, sizeX = 1, sizeY = 1) {
                    super(x, y);
                    this.biome = biome;
                    /** @type {Object.<string, Number>} */
                    this.prevalences = {}
                    this.sizeX = sizeX;
                    this.sizeY = sizeY;
                    this.building = 'none';
                    this.#offsetInit(prevalenceOffset);
                }
                /** @param {Number[]} offsets */
                #offsetInit(offsets) {
                    for (let i = 0; i < offsets.length; i++) {
                        this.prevalences[MATERIALS_1[i].name] = MATERIALS_1[i].basePrevalence + offsets[i];
                    }
                }
                /** @param {Number} x @param {Number} y */
                static makeCoords(x, y) {
                    return `x${String(x)}y${String(y)}`
                }
            }
            class NaturalBuilding {
                /** @param {String} buildingName @param {Number} spawnChance @param {Number} sizeX @param {Number} sizeY */
                constructor(buildingName, spawnChance, sizeX = 1, sizeY = 1) {
                    this.name = buildingName;
                    this.spawnChance = spawnChance;
                    this.sizeX = sizeX;
                    this.sizeY = sizeY;
                }
                /** @callback spawnCallback @param {MapTile} tile @returns {Boolean} */
                /** @param {spawnCallback} spawnRequirements @param {Number} sizeX @param {Number} sizeY */
                spawn(spawnRequirements, x, y) {
                    const coords = MapTile.makeCoords(x, y);
                    const tile = map[coords];
                    if (Math.random() > this.spawnChance) {
                        return;
                    }
                    if (!spawnRequirements(tile)) {
                        return;
                    }
                    if (tile.sizeX < this.sizeX || tile.sizeY < this.sizeY) {
                        return;
                    }
                    tile.building = this.name;
                }
            }
        </script>
        <!-- functions -->
        <script>
            const EM = {
                /** @param {String} id */
                elementID: function (id) { return document.getElementById(id); },
                /** @param {String} classname */
                elementsClass: function (classname) { return document.getElementsByClassName(classname); },
                /** @param {HTMLElement} element */
                elementText: function (element, text) { element.innerHTML = text; }
            }
            function doesExist(value) { return value == undefined ? false : true; }
            function randomNumber(min = 0, max = 1) { min = Math.ceil(min); max = Math.floor(max); return Math.round(Math.random() * (max - min) + min); }
            function isDigit(string = '0') {return /^\d+$/.test(string);}
        </script>
        <!-- data storage -->
        <script>
            //error constants
            //playerdata
            //inventory
            const ERROR_NOITEM = -1;
            const ERROR_NOTENOUGHITEM = -2;
            const ERROR_NOTENOUGHSPACE = -3
            // parser constants
            const PARSER_NONE = 0;
            const PARSER_MOVEONMAP = 1;
            const PARSER_MINEAREA = 2;
            const PARSER_CRAFT = 3;
            const PARSER_CRAFTAMOUNT = 4;
            const PARSER_SELL = 5;
            const PARSER_SELLAMOUNT = 6;
            const PARSER_RECIPEBROWSE = 7;
            // secondary parser constants
            const SPARSER_NONE = 0;
            const SPARSER_MINEVILLAGE = 1;
            const SPARSER_MININGVILLAGE = 2;
            //sum summus
            //items
            /** @type {Array.<CraftableItem|Tool>} */
            const ITEMS_1 = [
                new CraftableItem(2, 'wood planks', [{ item: 'wood', amount: 3 }], 1, 4),
                new CraftableItem(1, 'rope', [{ item: 'plants', amount: 3 }], 2, 2),
                new CraftableItem(1, 'flint', [{ item: 'stone', amount: 2 }], 1, 2),
                new CraftableItem(2, 'firewood', [{ item: 'wood planks', amount: 1 }], 1, 6),
                new CraftableItem(1, 'medicinal herbs', [{ item: 'plants', amount: 2 }], 1, 4),
                new CraftableItem(3, 'flint weaponry', [{ item: 'wood', amount: 2 }, { item: 'flint', amount: 2 }, { item: 'rope', amount: 1 }], 1, 12),
                new CraftableItem(6, 'obsidian weaponry', [{ item: 'wood', amount: 2 }, { item: 'obsidian', amount: 2 }, { item: 'rope', amount: 2 }], 1, 30),
                new Tool(5, 'stone tools', [{ item: 'wood', amount: 3 }, { item: 'stone', amount: 4 }, { item: 'rope', amount: 1 }], { returns: 1, speed: 1.2, tier: 0 }, 12),
                new Tool(8, 'obsidian tools', [{ item: 'wood', amount: 3 }, { item: 'obsidian', amount: 2 }, { item: 'rope', amount: 2 }], { returns: 1, speed: 1.5, tier: 1 }, 32),
                new CraftableItem(10, 'survival pack', [{ item: 'stone tools', amount: 1 }, { item: 'flint weaponry', amount: 1 }, { item: 'medicinal herbs', amount: 2 }, { item: 'rope', amount: 3 }], 1, 40),
                new CraftableItem(5, 'firestarting kit', [{ item: 'firewood', amount: 2 }, { item: 'flint', amount: 2 }], 1, 16),
                new CraftableItem(3, 'hide clothes', [{ item: 'hide', amount: 6 }, { item: 'rope', amount: 1 }], 1, 16)
            ];
            //autogenerated buildings
            const STRUCTURES_1 = {
                village: new NaturalBuilding('village', 0.075, 1, 1)
            }
        </script>
    </div>
    <!-- functional scripts -->
    <div>
        <script>
            let playerData = {
                tempStorage: '',
                lastInput: '',
                doingAction: false,
                location: {
                    vector: new Vector2(randomNumber(-99, 99), randomNumber(-99, 99)),
                    getCoords: function () {
                        return `x${String(this.vector.x)}y${String(this.vector.y)}`;
                    }
                },
                materials: {
                    wood: 0,
                    stone: 0,
                    clay: 0
                },
                inventory: {
                    maxvolume: 250,
                    volume: 0,
                    /** @type {Array.<String>} */
                    list: [],
                    /** @type {Array.<Number>} */
                    listamounts: [],
                    /**  @param {String} item */
                    addItem: function (item, amount = 1) {
                        if (this.list.includes(item)) {
                            this.listamounts[this.list.indexOf(item)] += amount;
                        }
                        else {
                            this.list.push(item);
                            this.listamounts.push(amount);
                        }
                    },
                    /** @param {String} item */
                    removeItem: function (item, amount = 1) {
                        if (this.list.includes(item)) {
                            if (this.listamounts[this.list.indexOf(item)] < amount) {
                                return ERROR_NOTENOUGHITEM;
                            }
                            else {
                                if (this.listamounts[this.list.indexOf(item)] - amount == 0) {
                                    this.listamounts.splice(this.list.indexOf(item), 1);
                                    this.list.splice(this.list.indexOf(item), 1);
                                }
                                else {
                                    this.listamounts[this.list.indexOf(item)] -= amount;
                                }
                            }
                        }
                        else {
                            return ERROR_NOITEM;
                        }
                    },
                    /** @param {String} item */
                    getItemAmount: function (item) {
                        return this.list.includes(item) ? this.listamounts[this.list.indexOf(item)] : ERROR_NOITEM;
                    }
                },
                perks: {
                    mining: {
                        speed: 1,
                        returns: 0,
                        tier: 0
                    }
                }
            }
            let parserKey = PARSER_NONE;
            let secondaryKey = SPARSER_NONE;
            EM.elementID('submit').addEventListener("click", (e) => {
                inputParser(EM.elementID('consoleinput').value);
                EM.elementID('submit').animate([
                    { backgroundColor: '#424242', color: '#ffffff' },
                    { backgroundColor: '#212121', color: '#999999' },
                    { backgroundColor: '#424242', color: '#ffffff' }
                ], {
                    duration: 150,
                    easing: "ease-in"
                })
            })
            EM.elementID('consoleinput').addEventListener("keydown", (e) => {
                if (e.key == 'Enter') {
                    inputParser(e.target.value);
                }
                if (e.key == 'ArrowUp') {
                    e.target.value = playerData.lastInput;
                }
            });
            /**  @param {String} value */
            function inputParser(value) {
                /** @param {String} input */
                function updateText(input, cons = 1) {
                    const whichconsole = cons == 1 ? '' : 'e';
                    const whichcons = cons == 1 ? '11' : '10';
                    for (let i = 1; i < Number(whichcons); i++) {
                        EM.elementID('console' + whichconsole + String(i)).innerHTML = EM.elementID('console' + whichconsole + String(i + 1)).innerHTML;
                    }
                    EM.elementID('console' + whichconsole + whichcons).innerHTML = '> ' + input;
                }
                function updateLine(input = 'lorem', line = 1, cons = 1) {
                    const whichconsole = cons == 1 ? '' : 'e';
                    EM.elementID('console' + whichconsole + String(line)).innerHTML = '> ' + input;
                }
                if (playerData.inventory.getItemAmount('coin') >= 250 && playerData.inventory.getItemAmount('pro gamer certificate') == ERROR_NOITEM) {
                    playerData.inventory.addItem('pro gamer certificate');
                    updateText('you got a pro gamer certificate', 2);
                }
                let text = value.toLowerCase();
                playerData.lastInput = text;
                EM.elementID('consoleinput').value = '';
                updateText(text);
                if (text == 'location' && parserKey == PARSER_NONE) {
                    updateText(`you are at x: ${String(playerData.location.vector.x)} y: ${String(playerData.location.vector.y)}`);
                    updateText(`your biome is ${map[`x${String(playerData.location.vector.x)}y${String(playerData.location.vector.y)}`].biome}`);
                }
                if ((text == 'move' && parserKey == PARSER_NONE) || parserKey == PARSER_MOVEONMAP) {
                    if (parserKey == PARSER_MOVEONMAP) {
                        let coords = playerData.location;
                        if (text == 'up') {
                            playerData.location.vector.y += 1;
                            setTimeout(() => {
                                if (map[playerData.location.getCoords()].building == 'village') {
                                    updateText('there is a village on this tile');
                                }
                            }, 101);
                        }
                        else if (text == 'down') {
                            playerData.location.vector.y -= 1;
                            setTimeout(() => {
                                if (map[playerData.location.getCoords()].building == 'village') {
                                    updateText('there is a village on this tile');
                                }
                            }, 101);
                        }
                        else if (text == 'left') {
                            playerData.location.vector.x -= 1;
                            setTimeout(() => {
                                if (map[playerData.location.getCoords()].building == 'village') {
                                    updateText('there is a village on this tile');
                                }
                            }, 101);
                        }
                        else if (text == 'right') {
                            playerData.location.vector.x += 1;
                            setTimeout(() => {
                                if (map[playerData.location.getCoords()].building == 'village') {
                                    updateText('there is a village on this tile');
                                }
                            }, 101);
                        }
                        parserKey = PARSER_NONE;
                    }
                    else {
                        updateText('input direction');
                        parserKey = PARSER_MOVEONMAP;
                    }
                }
                if ((text == 'mine' && parserKey == PARSER_NONE) || parserKey == PARSER_MINEAREA) {
                    if (!playerData.doingAction) {
                        if (parserKey == PARSER_MINEAREA) {
                            if (secondaryKey === SPARSER_MINEVILLAGE) {
                                secondaryKey = text == 'yes' ?  SPARSER_MININGVILLAGE : SPARSER_NONE;
                                parserKey = text == 'yes' ? PARSER_MINEAREA : PARSER_NONE;
                            }
                            else if (secondaryKey === SPARSER_NONE || secondaryKey === SPARSER_MININGVILLAGE) {
                                let input = 0;
                                if (!isDigit(text)) {
                                    input = 1;
                                }
                                else {
                                    input = Math.ceil(Number(text));
                                }
                                if (input > 60) {
                                    input = 60;
                                }
                                if (secondaryKey == SPARSER_MININGVILLAGE) {
                                    playerData.inventory.removeItem('coin', Math.ceil(input * 1.25));
                                }
                                /** @type {MapTile} */
                                const tile = map[playerData.location.getCoords()];
                                /** @type {String[]} */
                                let materialOutput = [];
                                /** @type {Number[]} */
                                let materialAmount = [];
                                /** @type {String[]} */
                                const locationbiome = tile.biome;
                                let availableMaterials = MATERIALS_1.filter((value) => { return value.biomes.includes('all') || value.biomes.includes(locationbiome) })
                                let total = 0;
                                /** @type {Number[]} */
                                let prevalences = [];
                                for (let i = 0; i < availableMaterials.length; i++) {
                                    total += map[playerData.location.getCoords()].prevalences[availableMaterials[i].name];
                                    prevalences.push(map[playerData.location.getCoords()].prevalences[availableMaterials[i].name]);
                                }
                                for (let i = 0; i < input; i++) {
                                    let start = 0;
                                    const RN = randomNumber(0, total);
                                    for (let o = 0; o < availableMaterials.length; o++) {
                                        const material = availableMaterials[o];
                                        if (NumberRange.betweenRange(new NumberRange(start, start + prevalences[o]), RN, true, o == availableMaterials.length - 1 ? true : false)) {
                                            if (!materialOutput.includes(material.name)) {
                                                materialOutput.push(material.name);
                                                materialAmount.push(1);
                                            }
                                            else {
                                                materialAmount[materialOutput.indexOf(material.name)] += 1;
                                            }
                                        }
                                        start += prevalences[o];
                                    }
                                }
                                /** @type {Object} */
                                EM.elementID('consolee1').innerHTML = '> []';
                                playerData.doingAction = true;
                                function updateProgressBar(progress) {
                                    const progressBarElement = EM.elementID('consolee1');
                                    const progressBarLength = 10;
                                    const progressBarString = "> [" + "-".repeat(progressBarLength * progress) + "]";
                                    progressBarElement.innerHTML = progressBarString;
                                    }
                                    const miningTime = 1000 * Number(input) / playerData.perks.mining.speed;
                                    let progress = 0;
                                    playerData.doingAction = true;
                                    const miningInterval = setInterval(() => {
                                    progress += 0.1;
                                    updateProgressBar(progress);
                                    if (progress >= 1) {
                                        clearInterval(miningInterval);
                                        playerData.doingAction = false;
                                        updateProgressBar(1);
                                        EM.elementID('consolee1').innerHTML = '> [Mining Done]';
                                    }
                                    }, miningTime / 10);
                                let inventory = playerData.inventory;
                                setTimeout(() => {
                                    let string = '';
                                    for (let a = 0; a < materialOutput.length; a++) {
                                        materialAmount[a] = secondaryKey == SPARSER_MININGVILLAGE ? Math.floor(materialAmount[a] * 1.5) : materialAmount[a];
                                        string = `${string}${materialAmount[a]} ${materialOutput[a]} `
                                    }
                                    updateLine(`you got ${string}`, 2, 2);
                                    for (let a = 0; a < materialOutput.length; a++) {
                                        const element = materialOutput[a];
                                        const elemen = materialAmount[a];
                                        playerData.inventory.addItem(element, elemen);
                                    }
                                }, (1000 * Number(input) / playerData.perks.mining.speed) + 1);
                                parserKey = PARSER_NONE;
                            }
                        }
                        else {
                            const build = map[playerData.location.getCoords()].building;
                            updateText(build === 'village' ? 'do you still want to mine, it\'ll cost money for mining in a village but you get more resources' : 'how many times to mine');
                            parserKey = PARSER_MINEAREA;
                            secondaryKey = build === 'village' ? SPARSER_MINEVILLAGE : SPARSER_NONE;
                        }
                    }
                    else {
                        updateText('already doing something');
                    }
                }
                if (text == 'clear' && parserKey == PARSER_NONE) {
                    for (let i = 0; i < 11; i++) {
                        updateText('');
                    }
                }
                if (text == 'inventory' && parserKey == PARSER_NONE) {
                    let string = 'you have ';
                    for (let i = 0; i < playerData.inventory.list.length; i++) {
                        const item = playerData.inventory.list[i];
                        const amount = playerData.inventory.listamounts[i];
                        if (i == playerData.inventory.list.length - 1 && playerData.inventory.list.length >= 3) {
                            string = `${string} ${amount} ${item}`;
                        }
                        else if (i != playerData.inventory.list.length - 1 && playerData.inventory.list.length >= 3) {
                            string = `${string} ${amount} ${item}, `
                        }
                        else if (i == 1 && playerData.inventory.list.length == 2) {
                            string = `${string} and ${amount} ${item}`;
                        }
                        else if (i == 0 && playerData.inventory.list.length == 2) {
                            string = `${string} ${amount} ${item} `;
                        }
                        else if (i == 0 && playerData.inventory.list.length == 1) {
                            string = `${string} ${amount} ${item}`;
                        }
                    }
                    if (playerData.inventory.list.length == 0) {
                        string = 'you have nothing';
                    }
                    updateText(string);
                }
                if ((text == 'craft' && parserKey == PARSER_NONE) || parserKey == PARSER_CRAFT) {
                    if (parserKey == PARSER_CRAFT) {
                        const index = ITEMS_1.findIndex((value) => { return value.name == text });
                        let mats = 0;
                        if (index != -1) {
                            for (let i = 0; i < ITEMS_1[index].costs.length; i++) {
                                const remove = playerData.inventory.removeItem(ITEMS_1[index].costs[i].item, ITEMS_1[index].costs[i].amount);
                                if (remove == ERROR_NOITEM) {
                                    updateText(`you don't have any ${ITEMS_1[index].costs[i].item}, you need ${ITEMS_1[index].costs[i].amount}`);
                                }
                                else if (remove == ERROR_NOTENOUGHITEM) {
                                    updateText(`you don't have enough ${ITEMS_1[index].costs[i].item}, you need ${ITEMS_1[index].costs[i].amount - playerData.inventory.getItemAmount(ITEMS_1[index].costs[i].item)} more`)
                                }
                                else {
                                    mats++;
                                }
                            }
                            if (mats == ITEMS_1[index].costs.length) {
                                playerData.inventory.addItem(ITEMS_1[index].name, ITEMS_1[index].craftMultiplier);
                            }
                            if (typeof ITEMS_1[index].perksPush === "function" && !(ITEMS_1[index].isUsed())) {
                                ITEMS_1[index].perksPush();
                            }
                        }
                        /*
                        costs are an array of objects with the properties item and amount
                        item is the name of the item needed to craft
                        amount is the amount of the item needed to craft
                        */
                        parserKey = PARSER_NONE;
                    }
                    else {
                        updateText('what to craft');
                        parserKey = PARSER_CRAFT;
                    }
                }
                if ((text == 'recipes' && parserKey == PARSER_NONE) || parserKey == PARSER_RECIPEBROWSE) {
                    if (parserKey == PARSER_NONE) {
                        for (let i = 0; i < 9 && i < ITEMS_1.length; i++) {
                            const value = ITEMS_1[i];
                            let string = `${value.name} costs:`
                            value.costs.forEach((valueb, index) => {
                                if (true) {
                                    string = `${string} ${valueb.amount} ${valueb.item}`
                                }
                            })
                            updateText(string);
                            if (i == 8) {
                                playerData.tempStorage = 8;
                                updateText('do you want to go to the next page');
                                parserKey = PARSER_RECIPEBROWSE;
                            }
                        }
                    }
                    else if (parserKey == PARSER_RECIPEBROWSE) {
                        if (text == 'no') {
                            parserKey = PARSER_NONE;
                        }
                        else if (text == 'yes') {
                            for (let i = 0; i < 10 && i + playerData.tempStorage < ITEMS_1.length; i++) {
                                const value = ITEMS_1[i + playerData.tempStorage];
                                let string = `${value.name} costs:`
                                value.costs.forEach((valueb, index) => {
                                    if (true) {
                                        string = `${string} ${valueb.amount} ${valueb.item}`
                                    }
                                })
                                if (i == 9 && i + playerData.tempStorage != ITEMS_1.length - 1) {
                                    playerData.tempStorage += 9;
                                    updateText('do you want to go to the next page');
                                }
                                else if (i + playerData.tempStorage == ITEMS_1.length - 1) {
                                    parserKey = PARSER_NONE;
                                }
                                updateText(string);
                            }
                        }
                    }
                }
                if ((text === 'sell' && parserKey === PARSER_NONE) || parserKey === PARSER_SELL || parserKey === PARSER_SELLAMOUNT) {
                    switch (parserKey) {
                        case PARSER_SELL:
                        if (text === 'cancel') {
                            parserKey = PARSER_NONE;
                        } else {
                            const exists = playerData.inventory.list.includes(text);
                            if (exists) {
                            playerData.tempStorage = text;
                            const itemAmount = playerData.inventory.getItemAmount(text);
                            updateText(`input how many to sell, you have ${itemAmount} ${text}`);
                            }
                            parserKey = PARSER_SELLAMOUNT;
                        }
                        break;
                        case PARSER_SELLAMOUNT:
                        const mat = MATERIALS_1.find(value => value.name === playerData.tempStorage);
                        const item = ITEMS_1.find(value => value.name === playerData.tempStorage);
                        let amount;
                        if (typeof mat !== 'undefined') {
                            amount = playerData.inventory.getItemAmount(mat.name);
                            const enoughmat = playerData.inventory.removeItem(mat.name, Number(text));
                            if (enoughmat !== ERROR_NOTENOUGHITEM) {
                            playerData.inventory.addItem('coin', mat.sellValue * Number(text));
                            updateText(`you got ${mat.sellValue * Number(text)} coins`);
                            } else {
                            playerData.inventory.addItem('coin', mat.sellValue * amount);
                            updateText(`you got ${mat.sellValue * amount} coins`);
                            playerData.inventory.removeItem(mat.name, amount);
                            }
                        }
                        if (typeof item !== 'undefined') {
                            amount = playerData.inventory.getItemAmount(item.name);
                            const enoughitem = playerData.inventory.removeItem(item.name, Number(text));
                            if (enoughitem !== ERROR_NOTENOUGHITEM) {
                            playerData.inventory.addItem('coin', item.sellValue * Number(text));
                            updateText(`you got ${item.sellValue * Number(text)} coins`);
                            } else {
                            playerData.inventory.addItem('coin', item.sellValue * amount);
                            updateText(`you got ${item.sellValue * amount} coins`);
                            playerData.inventory.removeItem(item.name, amount);
                            }
                        }
                        parserKey = PARSER_NONE;
                        break;
                        default:
                        updateText('input what to sell, or say cancel to cancel');
                        parserKey = PARSER_SELL;
                        break;
                    }
                    }
                // if (text == 'tset') {
                //     MATERIALS_1.forEach((value) => {
                //         playerData.inventory.addItem(value.name, 999);
                //     });
                //     ITEMS_1.forEach((value) => {
                //         playerData.inventory.addItem(value.name, 999);
                //     });
                //     console.log(playerData.perks.mining.speed);
                // }

            }
        </script>
        <script>
            /** @type {Object.<string, MapTile>} */
            let map = {};
            {
                let chosen = false;
                setInterval(() => {
                    if (!map.hasOwnProperty(playerData.location.getCoords())) {
                        //eventually use algorithm based on material's stats and what biomes its in to calculate offsets
                        const biomes = [
                            { name: 'plains', prevalenceOffset: [[0, 1], [1, 2], [0, 1], [0, 2], [0, 0], [-1, 0]], likelihood: 3 },
                            { name: 'tundra', prevalenceOffset: [[0, 0], [-1, -1], [0, 0], [-2, -1], [0, 0], [0, 1]], likelihood: 0.5},
                            { name: 'savannah', prevalenceOffset: [[0, 1], [2, 3], [0, 0], [1, 2], [0, 0], [0, 1]], likelihood: 1 },
                            { name: 'tropical forest', prevalenceOffset: [[-2, -1], [3, 5], [-1, 0], [3, 5], [0, 0], [0, 0]], likelihood: 1 },
                            { name: 'forest', prevalenceOffset: [[2, 2], [3, 4], [0, 0], [2, 2], [0, 0], [0, 1]], likelihood: 2 },
                            { name: 'desert', prevalenceOffset: [[0, 0], [-1, 0], [0, 0], [0, 0], [0, 0], [0, 0]], likelihood: 1 },
                            { name: 'mountain', prevalenceOffset: [[2, 3], [-1, -1], [0, 0], [0, 0], [0, 0], [0, 0]], likelihood: 1 },
                            { name: 'volcano', prevalenceOffset: [[14, 15], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]], likelihood: 0.1 },
                        ];
                        const randomBiome = biomes.find(biome => Math.random() < biome.likelihood / 10);
                        const prevalences = function () { let returnArr = []; randomBiome.prevalenceOffset.forEach((value) => { returnArr.push(randomNumber(value[0], value[1])) }); return returnArr }()
                        const name = `x${String(playerData.location.vector.x)}y${String(playerData.location.vector.y)}`;
                        if (!map.hasOwnProperty(playerData.location.getCoords())) {
                            map[name] = new MapTile(playerData.location.vector.x, playerData.location.vector.y, randomBiome.name, prevalences, randomNumber(1, 3), randomNumber(1, 3));
                        }
                        STRUCTURES_1.village.spawn((tile) => {
                            return ['forest', 'plains', 'savannah', 'tropical forest'].includes(tile.biome);
                        }, playerData.location.vector.x, playerData.location.vector.y);
                        chosen = false;
                    }
                }, 100);
            }  
        </script>
    </div>
    <footer>
        <b style="font-size: 12px;">rubenhdz1213, ©2023 totally</b>
    </footer>
</body>

</html>