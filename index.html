<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="mining.ico">
    <title>Mineral Madness</title>
</head>

<body>
    <div id="popup">Your message here!</div>
    <div id="motc">
        <h1>Mineral Madness</h1>
        <!-- <p style="font-size: 0.85vw; color: red;" id="motcu">"U" before a version means it is unstable and/or unusable, while the number after the "U" tells you what is the current unstable build of that version*</p> -->
        <h3 id="motctitle" style="line-height: 6px; font-size: 16px">MOTC<!-- <divisor style="color: red">U4*</divisor> --> 0.6.3</h3>
        <div class="motctext" style="font-size: 10px">theres now a wiki with these changelogs on the <a href="https://github.com/rubenhdz1213/rubenhdz1213.github.io/wiki/">repository</a></div>
        <div class="motctext" style="font-size: 10px;">you can now only hire at villages, and each village now has a set limit to how much you can hire, and they will mine one of the tiles adjacent to the village instead of where you're standing</div>
        <div class="motctext" style="font-size: 10px;">0.7 will now instead add several new features like automated crafting and exploring nearby areas at the cost of a few coins when at a village</div>
        <div class="motctext" style="font-size: 10px;">biome gen changing will be pushed to v0.15 or further</div>
        <div class="motctext" style="font-size: 10px">0.6.3 refines map generation, patches bugs, makes the consoles more clean, and refines most of the game's code, while 0.6.4 will remake the classes from the ground up to be more readable and expandable</div>
        <!-- <p style="color: red; font-size: 12px; line-height: 1px;" id="motcutext1">recipes command exists</p>
        <p style="color: red; font-size: 12px; line-height: 1px;" id="motcutext2">crafting is fixed but perks from tools dont exist yet</p>
        <p style="color: red; font-size: 12px; line-height: 1px;" id="motcutext3">there is now a cool looking submit button for mobile and stuff as well as a better looking input</p> -->
    </div>
    <div id="console">
        <div id="console1"></div>
    </div>
    <div id="consolecontrols">
        <input type="text" id="consoleinput" style=" color: white; border-style: solid; border-color: black;">
        <button id="submit">Submit</button>
    </div>
    <div id="consolee">
        <div id="consolee1"></div>
    </div>
    <!-- utility scripts -->
    <div>
        <!-- classes -->
        <script>
            class Vector2 {
                /** @param {Number} x @param {Number} y @param {Number} rotation */
                constructor(x, y, rotation) {
                    this.x = x;
                    this.y = y;
                    this.rotation = rotation % 360;
                }
                /** @param {Vector2[]} vectors */
                static addVectors(vectors) {
                    let sumx = 0;
                    let sumy = 0;
                    let sumr = 0;
                    for (let i = 0; i < vectors.length; i++) {
                        sumx += vectors[i].x;
                        sumy += vectors[i].y;
                        sumr += vectors[i].rotation;
                    }
                    return new Vector2(sumx, sumy, sumr);
                }
                /** @param {Vector2[]} vectors */
                static subtractVectors(vectors) {
                    let diffx = 0;
                    let diffy = 0;
                    let diffr = 0;
                    for (let i = 0; i < vectors.length; i++) {
                        diffx -= vectors[i].x;
                        diffy -= vectors[i].y;
                        diffr -= vectors[i].rotation
                    }
                    return new Vector2(diffx, diffy, diffr);
                }
            }
            class NumberRange {
                /** @param {Number} min @param {Number} max @param {Boolean} inclusiveMin @param {Boolean} inclusiveMax */
                constructor(min, max, inclusiveMin, inclusiveMax) {
                    this.min = min;
                    this.max = max;
                    this.inclusiveMax = inclusiveMax;
                    this.inclusiveMin = inclusiveMin;
                }
                /** @param {Number} number @param {Number} offsetMin @param {Number} offsetMax */
                betweenRange(number, offsetMin = 0, offsetMax = 0) {
                    let withinRange = true;
                    if (this.inclusiveMin) {
                        if (number < this.min + offsetMin) {
                            withinRange = false;
                        }
                    }
                    else {
                        if (number <= this.min + offsetMin) {
                            withinRange = false;
                        }
                    }
                    if (this.inclusiveMax) {
                        if (number > this.max + offsetMin) {
                            withinRange = false;
                        }
                    }
                    else {
                        if (number >= this.max + offsetMin) {
                            withinRange = false;
                        }
                    }
                    return withinRange;
                }
                /** @param {Number} offsetMin @param {Number} offsetMax */
                randomWithinRange(offsetMin, offsetMax) {
                    return randomNumber(this.min + offsetMin, this.max + offsetMax);
                }
            }
            class Item {
                /** @param {Number} itemVolume @param {String} itemName @param {Number} cost @param {String} type */
                constructor(itemVolume, itemName, cost, type) {
                    this.volume = itemVolume;
                    this.name = itemName;
                    this.sellValue = cost;
                    this.type = type;
                }
                /** @param {Number} amount */
                inventoryPush(amount) {
                    playerData.addItem(this.name, amount);
                }
            }
            class MapComponent {
                /** @param {Number} x @param {Number} y */
                constructor(x, y) {
                    this.coordinates = new Vector2(x, y);
                }
                /** @param {Number} x @param {Number} y */
                shiftLocation(x, y) {
                    this.coordinates.x += x;
                    this.coordinates.y += y;
                }
            }
            class Material extends Item {
                /** @param {Number} materialVolume @param {String} materialName @param {Number} basePrevalence @param {String[]} biomes @param {Number} cost*/
                constructor(materialVolume, materialName, basePrevalence, biomes = ['all'], cost) {
                    super(materialVolume, materialName, cost);
                    this.basePrevalence = basePrevalence;
                    this.biomes = biomes;
                }
            }
            //materials
            const MATERIALS_1 = [
                new Material(2, 'stone', 2, undefined, 1),
                new Material(1, 'wood', 2, ['plains', 'forest', 'desert', 'mountain', 'savannah', 'tropical forest'], 1),
                new Material(1, 'clay', 1, ['plains', 'forest', 'savannah', 'tropical forest'], 1),
                new Material(1, 'plants', 2, ['plains', 'forest', 'savannah', 'tropical forest'], 1),
                new Material(2, 'obsidian', 1, ['volcano'], 10),
                new Material(1, 'hide', 1, ['plains', 'forest', 'savannah', 'tropical forest'], 2)
            ];
            class CraftableItem extends Item {
                /** @param {Number} itemVolume @param {String} itemName @param {Object[]} costs @param {String} costs[].item @param {Number} costs[].amount @param {Number} multiplier @param {Number} sellValue*/
                constructor(itemVolume, itemName, costs, multiplier = 1, sellValue/*, tier */) {
                    super(itemVolume, itemName, sellValue, 'craftable');
                    this.costs = costs;
                    this.craftMultiplier = multiplier;
                    //this.craftingTier = tier;
                }
            }
            class Tool extends CraftableItem {
                #hasBeenUsed = false;
                /** @param {Number} toolVolume @param {String} toolName @param {Object[]} costs @param {String} costs[].item @param {Number} costs[].amount @param {Object} miningPerks @param {Number} miningPerks.speed @param {Number} miningPerks.returns @param {Number} miningPerks.tier*/
                constructor(toolVolume, toolName, costs, miningPerks, sellValue) {
                    super(toolVolume, toolName, costs, 1, sellValue);
                    this.type = 'tool';
                    this.perks = {
                        mining: miningPerks,
                    }
                }
                perksPush() {
                    this.#hasBeenUsed = true;
                    playerData.perks.mining.returns *= this.perks.mining.returns;
                    playerData.perks.mining.speed *= this.perks.mining.speed;
                    playerData.perks.mining.tier = this.perks.mining.tier > playerData.perks.mining.speed ? this.perks.mining.tier : playerData.perks.mining.tier;
                    playerData.perks.mining.returns = playerData.perks.mining.returns.toPrecision(2);
                    playerData.perks.mining.speed = playerData.perks.mining.speed.toPrecision(2);
                }
                isUsed() {
                    return this.#hasBeenUsed;
                }
            }
            class MapTile extends MapComponent {
                /** @param {Number} x @param {Number} y @param {String} biome @param {Number[]} prevalenceOffset @param {Number} richness @param {Number} sizeX @param {Number} sizeY */
                constructor(x = 0, y = 0, biome, prevalenceOffset, richness, sizeX = 1, sizeY = 1) {
                    super(x, y);
                    this.biome = biome;
                    /** @type {Object.<string, Number>} */
                    this.prevalences = {}
                    this.sizeX = sizeX;
                    this.sizeY = sizeY;
                    this.tileData = {
                        /** @typedef {Object} BuildingDataObject @property {String} name @property {String} type */
                        /** @type {Object.<string, BuildingDataObject>} */
                        buildingData: {},
                        materialDensity: richness
                    };
                    this.#offsetInit(prevalenceOffset);
                }
                /** @param {Number[]} offsets */
                #offsetInit(offsets) {
                    for (let i = 0; i < offsets.length; i++) {
                        this.prevalences[MATERIALS_1[i].name] = MATERIALS_1[i].basePrevalence + offsets[i];
                    }
                }
                /** @param {Number} x @param {Number} y */
                static makeCoords(x, y) {
                    return `x${String(x)}y${String(y)}`
                }
                get buildings() {
                    return Object.keys(this.tileData.buildingData).map(value => this.tileData.buildingData[value]);
                }
            }
            class NaturalBuilding {
                /** @param {String} buildingName @param {Number} spawnChance @param {Number} sizeX @param {Number} sizeY */
                constructor(buildingName, spawnChance, sizeX = 1, sizeY = 1) {
                    this.name = buildingName;
                    this.spawnChance = spawnChance;
                    this.sizeX = sizeX;
                    this.sizeY = sizeY;
                }
                /** @callback spawnCallback @param {MapTile} tile @returns {Boolean} */
                /** @summary spawns the building if spawnRequirements() returns true and condenses extraInit like key-value pairs
                 *  @param {spawnCallback} spawnRequirements @param {Number} sizeX @param {Number} sizeY @param {Array[]} extraInit  */
                spawn(spawnRequirements, x, y, extraInit) {
                    const coords = MapTile.makeCoords(x, y);
                    const tile = map[coords];
                    if (Math.random() > this.spawnChance) {
                        return;
                    }
                    if (tile.sizeX < this.sizeX || tile.sizeY < this.sizeY) {
                        return;
                    }
                    if (!spawnRequirements(tile)) {
                        return;
                    }
                    tile.tileData.buildingData[this.name] = Object.assign({ name: this.name, type: 'natural' }, Object.fromEntries(extraInit));
                }
            }
            class Building {
                /** @typedef {Object} cost @property {Number} amount @property {String} name */
                /** @param {String} buildingName */
                constructor(buildingName, costs, size = [1, 0]) {
                    this.name = buildingName;
                    this.costs = costs;
                    [this.sizeX, this.sizeY] = size;
                }
            }
            //for v0.7
            class Biome {
                /** @param {String} name @param {Number[][]} offsets */
                constructor(name, offsets, likelihood = 1, skeweringX = 0, skeweringY = 0) {
                    this.name = name;
                    this.prevalenceOffsets = offsets;
                    this.likelihood = likelihood;
                    this.skewX = skeweringX;
                    this.skewY = skeweringY;
                }
            }
            const biomes = [
                new Biome('plains', [[0, 1], [1, 2], [0, 1], [0, 2], [0, 0], [-1, 0]], 0.3, 0, 0),
                new Biome('forest', [[2, 2], [3, 4], [0, 0], [2, 2], [0, 0], [0, 1]], 0.2, -600, 600),
                new Biome('tropical forest', [[-2, -1], [3, 5], [-1, 0], [3, 5], [0, 0], [0, 0]], 0.1, -1000, 1),
                new Biome('savannah', [[0, 1], [2, 3], [0, 0], [1, 2], [0, 0], [0, 1]], 0.1, 600, 400),
                new Biome('desert', [[0, 0], [-1, 0], [0, 0], [0, 0], [0, 0], [0, 0]], 0.1, 600, 1),
                new Biome('mountain', [[2, 3], [-1, -1], [0, 0], [0, 0], [0, 0], [0, 0]], 0.1, 0, 2500),
                new Biome('tundra', [[0, 0], [-1, -1], [0, 0], [-2, -1], [0, 0], [0, 1]], 0.05, 0, 2250),
                new Biome('wasteland', [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]], 0.025, 0, 4000),
                new Biome('volcano', [[14, 15], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]], 0.025, 800, 0)
            ];
        </script>
        <!-- functions -->
        <script>
            const EM = {
                /** @param {String} id */
                elementID: function (id) { return document.getElementById(id); },
                /** @param {String} classname */
                elementsClass: function (classname) { return document.getElementsByClassName(classname); },
                /** @param {HTMLElement} element */
                elementText: function (element, text) { element.innerHTML = text; }
            }
            /** @param {String} message */
            function showPopup(message) {
                const popup = EM.elementID('popup');
                popup.innerText = message;
                popup.style.opacity = 1;
                setTimeout(() => {
                    popup.style.opacity = 0;
                }, 500);
            }
            /** @type {HTMLElement} */
            let storage = EM.elementID('console1');
            /** @type {HTMLElement} */
            let storage2 = EM.elementID('consolee1');
            /** @param {String} input */
            function updateText(input, cons = 1, trash = false) {
                const cl = `consol${'e'.repeat(cons)}text`;
                const id = `consol${'e'.repeat(cons)}`;
                const element = document.createElement('div');
                element.className = cl;
                element.innerText = `[${playerData.x}, ${playerData.y}]-> ${input}`
                EM.elementID(id).insertBefore(element, cons == 1 ? storage : storage2);
                cons == 1 ? storage = element : storage2 = element;
                return element;
            }
            /** @typedef {Object} mat @property {String} name @property {Number} amount */
            /** @param {MapTile} tile */
            function mineLocation(mineAmount = 1, tile, multiplier = 1, speed = 1) {
                /** @type {Object.<string, mat>} */
                let materialOutput = {};
                const input = isDigit(mineAmount) ? Number(mineAmount) <= 60 ? Number(mineAmount) : 60 : 1;
                const availableMaterials = MATERIALS_1.filter(value => value.biomes.includes('all') || value.biomes.includes(tile.biome));
                /** @type {Number} total */
                const total = availableMaterials.reduce(/** @param {Number} accumulator */(accumulator, material) => { accumulator = isDigit(accumulator) ? accumulator : 0; return accumulator + tile.prevalences[material.name]; });
                const prevalences = availableMaterials.map(value => tile.prevalences[value.name]);
                for (let i = 0; i < input; i++) {
                    let start = 0;
                    const RN = randomNumber(0, total);
                    availableMaterials.forEach((value, index, arr) => {
                        if (new NumberRange(start, start + prevalences[index], true, index + 1 === arr.length).betweenRange(RN)) {
                            materialOutput[value.name] ??= { name: value.name, amount: 0 };
                            materialOutput[value.name].amount += 1 * multiplier;
                        }
                        start += prevalences[index];
                    });
                }
                const materials = Object.values(materialOutput);
                setTimeout(() => {
                    materials.forEach((material) => {
                        playerData.addItem(material.name, Math.floor(material.amount));
                    });
                }, (1000 * Number(input)) / speed);
                return materials;
            }
            function newTile(x = 0, y = 0, overwrite = false) {
                return new Promise(
                    (resolve, reject) => {
                        const biomeChances = biomes.map(value => value.likelihood);
                        const randomBiome = function(){const random = Math.random(); let sum = 0; for (let i = 0; i < biomeChances.length; i++) {sum += biomeChances[i]; if (random <= sum) {return biomes[i]}}}();
                        const prevalences = randomBiome.prevalenceOffsets.map((value) => randomNumber(value[0], value[1]));
                        const name = MapTile.makeCoords(x, y);
                        if (!map.hasOwnProperty(name) || overwrite) {
                            map[name] = new MapTile(x, y, randomBiome.name, prevalences, randomNumber(10, 14) / 10, randomNumber(1, 3), randomNumber(1, 3));
                        }
                        else if (!overwrite) {
                            reject('tile already spawned');
                        }
                        STRUCTURES_1.village.spawn(STRUCTURES_1.spawnVillage, x, y, [['workers', 0], ['cashMulti', randomNumber(10, 15) / 10]]);
                        if(map.hasOwnProperty(name)) {
                            resolve('spawned tile');
                        }
                    }
                )
            }
            /** @param {String} citem @param {Number} amount @param {Boolean} log */
            function craftItem(citem, amount, log) {
                const index = ITEMS_1.findIndex((value) => { return value.name == citem.replace('-', ' ') });
                let mats = 0;
                if (index != -1) {
                    const item = ITEMS_1[index];
                    let matsused = [];
                    item.costs.forEach((value) => {
                        const amt = value.amount;
                        const itemn = value.item;
                        const remove = playerData.removeItem(itemn, amt);
                        const message = (remove == ERROR_NOITEM) 
                            ? `you don't have any ${itemn}, you need ${amt}`
                            : (remove == ERROR_NOTENOUGHITEM)
                            ? `you don't have enough ${itemn}, you need ${amt - playerData.getAmt(itemn)} more`
                            : (matsused.push(value), mats++, '');
                        !log || updateText(message, 1, message == '');
                    });
                    console.log(mats);
                    mats == item.costs.length
                        ? (playerData.addItem(item.name, item.craftMultiplier * amount), !log || updateText(`crafted ${amount} ${item.name}`))
                        : matsused.forEach(material => playerData.addItem(material.item, material.amount));
                    if (mats == 0) {return ERROR_NOINGREDIENTS} else if (mats < item.costs.length) {return ERROR_NOTENOUGHINGREDIENTS}
                    item?.perksPush();
                    return item;
                }
            }
            function doesExist(value) { return !(value === undefined); }
            function randomNumber(min = 0, max = 1) { min = Math.ceil(min); max = Math.floor(max); return Math.round(Math.random() * (max - min) + min); }
            function isDigit(string = '0') { return /^\d+$/.test(string); }
        </script>
        <!-- data storage -->
        <script>
            //error constants
            //crafting
            const ERROR_NOINGREDIENTS = -1;
            const ERROR_NOTENOUGHINGREDIENTS = -2; 
            //inventory
            const ERROR_NOITEM = -1;
            const ERROR_NOTENOUGHITEM = -2;
            const ERROR_NOTENOUGHSPACE = -3
            //return constants
            const OK = 0;
            //sum summus
            //items
            /** @type {Array.<CraftableItem|Tool>} */
            const ITEMS_1 = [
                new CraftableItem(2, 'wood planks', [{ item: 'wood', amount: 3 }], 1, 4),
                new CraftableItem(1, 'rope', [{ item: 'plants', amount: 3 }], 2, 2),
                new CraftableItem(1, 'flint', [{ item: 'stone', amount: 2 }], 1, 2),
                new CraftableItem(2, 'firewood', [{ item: 'wood planks', amount: 1 }], 1, 6),
                new CraftableItem(1, 'medicinal herbs', [{ item: 'plants', amount: 2 }], 1, 4),
                new CraftableItem(3, 'flint weaponry', [{ item: 'wood', amount: 2 }, { item: 'flint', amount: 2 }, { item: 'rope', amount: 1 }], 1, 12),
                new CraftableItem(6, 'obsidian weaponry', [{ item: 'wood', amount: 2 }, { item: 'obsidian', amount: 2 }, { item: 'rope', amount: 2 }], 1, 30),
                new Tool(5, 'stone tools', [{ item: 'wood', amount: 3 }, { item: 'stone', amount: 4 }, { item: 'rope', amount: 1 }], { returns: 1, speed: 1.2, tier: 0 }, 12),
                new Tool(8, 'obsidian tools', [{ item: 'wood', amount: 3 }, { item: 'obsidian', amount: 2 }, { item: 'rope', amount: 2 }], { returns: 1, speed: 1.5, tier: 1 }, 32),
                new CraftableItem(10, 'survival pack', [{ item: 'stone tools', amount: 1 }, { item: 'flint weaponry', amount: 1 }, { item: 'medicinal herbs', amount: 2 }, { item: 'rope', amount: 3 }], 1, 40),
                new CraftableItem(5, 'firestarting kit', [{ item: 'firewood', amount: 2 }, { item: 'flint', amount: 2 }], 1, 16),
                new CraftableItem(3, 'hide clothes', [{ item: 'hide', amount: 6 }, { item: 'rope', amount: 1 }], 1, 16)
            ];
            //player buildings
            //autogenerated buildings
            const STRUCTURES_1 = {
                villageObj: { 
                    structure: new NaturalBuilding('village', 0.075, 1, 1), 
                    /** @param {MapTile} tile */
                    spawnFunction(tile) {
                        return ['forest', 'plains', 'savannah', 'tropical forest'].includes(tile.biome) && function() { 
                            let canspawn = true;
                            [[-1, 0], [1, 0], [0, -1], [0, 1]].forEach((value) => {
                                const buildingcheckcoords = MapTile.makeCoords(tile.coordinates.x + value[0], tile.coordinates.y + value[1]); 
                                if (typeof map[buildingcheckcoords] !== "undefined") {
                                    canspawn = map[buildingcheckcoords].building !== 'none' ? false : canspawn;
                                }}); 
                                return canspawn; }(); }
                },
                get village() {
                    return this.villageObj.structure;
                },
                get spawnVillage() {
                    return this.villageObj.spawnFunction;
                }
            }
        </script>
    </div>
    <!-- functional scripts -->
    <div>
        <script>
            let playerData = {
                tempStorage: '',
                lastInput: '',
                doingAction: false,
                location: {
                    vector: new Vector2(randomNumber(1, 2) === 1 ? randomNumber(-800, -600) : randomNumber(600, 800), randomNumber(-99, 99)),
                    getCoords: function () {
                        return `x${String(this.vector.x)}y${String(this.vector.y)}`;
                    }
                },
                materials: {
                    wood: 0,
                    stone: 0,
                    clay: 0
                },
                inventory: {
                    maxvolume: 250,
                    volume: 0,
                    /** @type {Array.<String>} */
                    list: [],
                    /** @type {Array.<Number>} */
                    listamounts: [],
                    /**  @param {String} item */
                    addItem: function (item, amount = 1) {
                        if (this.list.includes(item)) {
                            this.listamounts[this.list.indexOf(item)] += amount;
                        }
                        else {
                            this.list.push(item);
                            this.listamounts.push(amount);
                        }
                        return OK;
                    },
                    /** @param {String} item */
                    removeItem: function (item, amount = 1) {
                        if (this.list.includes(item)) {
                            if (this.listamounts[this.list.indexOf(item)] < amount) {
                                return ERROR_NOTENOUGHITEM;
                            }
                            else {
                                if (this.listamounts[this.list.indexOf(item)] - amount == 0) {
                                    this.listamounts.splice(this.list.indexOf(item), 1);
                                    this.list.splice(this.list.indexOf(item), 1);
                                }
                                else {
                                    this.listamounts[this.list.indexOf(item)] -= amount;
                                }
                            }
                        }
                        else {
                            return ERROR_NOITEM;
                        }
                        return OK;
                    },
                    /** @param {String} item */
                    getItemAmount: function (item) {
                        return this.list.includes(item) ? this.listamounts[this.list.indexOf(item)] : ERROR_NOITEM;
                    }
                },
                workers: {
                    /** @typedef {Object} Miner @property {Vector2} coords @property {Number} multiplier @property {Number} speed */
                    /** @type {Miner[]} */
                    miners: []
                },
                perks: {
                    mining: {
                        speed: 1,
                        returns: 0,
                        tier: 0
                    }
                },
                get x() {
                    return this.location.vector.x;
                },
                get y() {
                    return this.location.vector.y;
                },
                get mapTile() {
                    return map[this.location.getCoords()];
                },
                get mapBuildings() {
                    return this.mapTile.tileData.buildingData;
                },
                /** @type {Function} */
                removeItem(item, amount = 1) {
                    return this.inventory.removeItem(item, amount);
                },
                addItem(item, amount = 1) {
                    return this.inventory.addItem(item, amount);
                },
                getAmt(item) {
                    return this.inventory.getItemAmount(item);
                },
                /** @param {String} item1 @param {Number} amount1 @param {String} item2 @param {Number} amount2 */
                exchangeItem(item1, amount1, item2, amount2) {
                    const canExchange = this.removeItem(item1, amount1);
                    if (typeof canExchange === "undefined") {
                        this.addItem(item2, amount2);
                    }
                    else {
                        return canExchange;
                    }
                }
            }
            EM.elementID('submit').addEventListener("click", (e) => {
                inputParser(EM.elementID('consoleinput').value);
                EM.elementID('submit').animate([
                    { backgroundColor: '#424242', color: '#ffffff' },
                    { backgroundColor: '#212121', color: '#999999' },
                    { backgroundColor: '#424242', color: '#ffffff' }
                ], {
                    duration: 150,
                    easing: "ease-in"
                })
            })
            EM.elementID('consoleinput').addEventListener("keydown", (e) => {
                if (e.key == 'Enter') {
                    const gen = inputParser();
                    gen.next()
                    gen.next(e.target.value);
                }
                if (e.key == 'ArrowUp') {
                    e.target.value = playerData.lastInput;
                }
            });
            /**  @param {String} parseInput */
            function* inputParser() {
                while (true) {
                    if (playerData.getAmt('coin') >= 250 && playerData.inventory.getItemAmount('pro gamer certificate') == ERROR_NOITEM) {
                        playerData.addItem('pro gamer certificate');
                        updateText('you got a pro gamer certificate', 2);
                    }
                    /** @type {String} t */
                    let t = yield 0;
                    let commands = t.toLowerCase().split(' ');
                    playerData.lastInput = t;
                    EM.elementID('consoleinput').value = '';
                    updateText(t);

                    if (commands[0] == 'location') {
                        updateText(`you are at x: ${String(playerData.x)} y: ${String(playerData.y)}`);
                        updateText(`your biome is ${playerData.mapTile.biome}`);
                    }

                    if (commands[0] == 'move') {
                        let coords = playerData.location;
                        const directions = {
                            north: [0, 1],
                            east: [1, 0],
                            south: [0, -1],
                            west: [0, 1],
                            northeast: [1, 1],
                            northwest: [-1, 1],
                            southeast: [1, -1],
                            southwest: [-1, -1]
                        }
                        playerData.location.vector.x += directions?.[commands[1]][0];
                        playerData.location.vector.y += directions?.[commands[1]][1];
                        !playerData.mapBuildings.village || updateText('there is a village on this tile');
                    }

                    if (commands[0] == 'mine') {
                        const input = isDigit(commands[1]) ? Number(commands[1]) <= 60 ? Number(commands[1]) : 60 : 1;
                        if (!playerData.doingAction) {
                            let multiplier = 1;
                            let canPay = false;
                            const village = Object.values(playerData.mapBuildings).map(value => value.name).includes('village');
                            if (village) {
                                updateText('do you still want to mine, it\'ll cost money for mining in a village but you get more resources');
                                const input = yield 0;
                                const enoughMoney = playerData.inventory.removeItem('coin', Math.ceil(input * 1.25));
                                multiplier = 1.5;
                                canPay = typeof enoughMoney === "undefined" && commands[2] === 'yes';
                            }
                            if (canPay || !village) {
                                const div = updateText('[]', 2);
                                playerData.doingAction = true;
                                function updateProgressBar(progress) {
                                    const progressBarLength = 10;
                                    const progressBarString = `[${playerData.x}, ${playerData.y}]-> [${"-".repeat(progressBarLength * progress)}]`;
                                    div.innerHTML = progressBarString;
                                }
                                const miningTime = 1000 * input / playerData.perks.mining.speed;
                                let progress = 0;
                                playerData.doingAction = true;
                                const miningInterval = setInterval(() => {
                                    progress += 0.1;
                                    updateProgressBar(progress);
                                    if (progress >= 1) {
                                        clearInterval(miningInterval);
                                        playerData.doingAction = false;
                                        updateProgressBar(1);
                                        div.innerHTML = `[${playerData.x}, ${playerData.y}]-> [Mining Done]`;
                                    }
                                }, miningTime / 10);
                                let inventory = playerData.inventory;
                                const output = mineLocation(input, playerData.mapTile, multiplier, playerData.perks.mining.speed);
                                const itemList = output.map((item, index, arr) => `${item.amount} ${item.name}${(index + 2 == arr.length && arr.length == 2) ? ' and ' : (arr.length == 1 ? '' : arr.length > 2 && index + 2 == arr.length ? ', and ' : arr.length != 2 && index + 1 != arr.length ? ', ' : '')}`).join('');
                                setTimeout(() => {
                                    updateText(`you got ${itemList}`, 2);
                                }, (1000 * Number(input) / playerData.perks.mining.speed) + 1);
                            }
                        }
                        else {
                            updateText('already doing something');
                        }
                    }

                    if (commands[0] == 'clear') {
                        EM.elementID('console').innerHTML = '<div id="console1"></div>'
                        storage = EM.elementID('console1');
                    }
                    
                    if (commands[0] == 'inventory') {
                        let string = 'you have ';
                        for (let i = 0; i < playerData.inventory.list.length; i++) {
                            const item = playerData.inventory.list[i];
                            const amount = playerData.inventory.listamounts[i];
                            if (i == playerData.inventory.list.length - 1 && playerData.inventory.list.length >= 3) {
                                string = `${string} ${amount} ${item}`;
                            }
                            else if (i != playerData.inventory.list.length - 1 && playerData.inventory.list.length >= 3) {
                                string = `${string} ${amount} ${item}, `
                            }
                            else if (i == 1 && playerData.inventory.list.length == 2) {
                                string = `${string} and ${amount} ${item}`;
                            }
                            else if (i == 0 && playerData.inventory.list.length == 2) {
                                string = `${string} ${amount} ${item} `;
                            }
                            else if (i == 0 && playerData.inventory.list.length == 1) {
                                string = `${string} ${amount} ${item}`;
                            }
                        }
                        if (playerData.inventory.list.length == 0) {
                            string = 'you have nothing';
                        }
                        updateText(string);
                    }

                    if (commands[0] == 'craft') {
                        if (commands.length < 3) {
                            updateText('craft syntax: craft <item> <amount>');
                        }
                        else {
                            const crafted = craftItem(commands[1], commands[2], true);
                            !(crafted instanceof CraftableItem) || updateText(`crafted ${commands[2]} ${crafted.name}`);
                        }
                    }

                    if (commands[0] == 'sell') {
                        if (commands.length < 3) {
                            updateText('sell syntax: sell <item> <amount>');
                        }
                        else {
                            const amount = isNaN(Number(commands[2])) ? 1 : Number(commands[2]);
                            const search = commands[1].replace('-', ' ');
                            const items = ITEMS_1.concat(MATERIALS_1); 
                            const item = items.find(value => value.name == search);
                            if (playerData.inventory.list.includes(search) && typeof item !== "undefined") {
                                if (playerData.inventory.getItemAmount(search) >= amount) {
                                    playerData.exchangeItem(search, amount, 'coin', item.sellValue * amount);
                                }
                            }
                        }
                    }
                    
                    if (commands[0] == 'hire') {
                        const tile = map[playerData.location.getCoords()];
                        if (tile.buildings.village) {
                            const downPayment = playerData.inventory.removeItem('coin', 20);
                            if ((downPayment !== ERROR_NOITEM) && (downPayment !== ERROR_NOTENOUGHITEM)) {
                                if (tile.buildings.village.workers < 5) {
                                    tile.buildings.willage.workers++;
                                    playerData.workers.miners.push({ coords: Vector2.addVectors([playerData.location.vector, new Vector2(randomNumber(0, 1) == 1 ? 1 : -1, randomNumber(0, 1) == 1 ? 1 : -1)]), multiplier: randomNumber (10, 12) / 10, speed: randomNumber(50, 60) / 100 });
                                }
                            }
                            else {
                                updateText('you dont have enough money to hire someone')
                            }
                        }
                        else {
                            updateText('you can\'t hire someone out of thin air')
                        }
                    }

                    // if (commands[0] == 'tset') {
                    //     playerData.addItem('coin', 20);
                    //     MATERIALS_1.forEach((value) => {
                    //         playerData.addItem(value.name, 999);
                    //     });
                    //     ITEMS_1.forEach((value) => {
                    //         playerData.addItem(value.name, 999);
                    //     });
                    // }
                }
            }
        </script>
        <script>
            /** @type {Object.<string, MapTile>} */
            let map = {};
            {
                let chosen = false;
                setInterval(() => {
                    if (!map.hasOwnProperty(playerData.location.getCoords())) {
                        newTile(playerData.location.vector.x, playerData.location.vector.y, false).then((resolution) => {console.log(`${resolution} @ ${playerData.location.getCoords()}`)});
                    }
                }, 100);
            }  
        </script>
        <script>
            const mineInterval = setInterval(() => {
                let cantPay = 0;
                playerData.workers.miners.forEach((value) => {
                    const canPay = playerData.inventory.removeItem('coin', 10);
                    if (canPay !== ERROR_NOITEM && canPay !== ERROR_NOTENOUGHITEM) {
                        mineLocation(Math.round(60 * value.speed), map[MapTile.makeCoords(value.coords.x, value.coords.y)], value.multiplier)
                    }
                    else {
                        cantPay++;
                    }
                });
                cantPay > 0 ? showPopup(`you dont have enough money to pay ${String(cantPay)} of your workers`, 2) : playerData.workers.miners.length == 0 || showPopup('paid all workers');
            }, 60000);
        </script>
    </div>
    <footer>
        <b style="font-size: 12px;">rubenhdz1213, ©2023 totally</b>
    </footer>
</body>

</html>