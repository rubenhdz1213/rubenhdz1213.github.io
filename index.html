<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="mining.ico">
    <title>Mineral Madness</title>
</head>

<body>
    <div id="motc">
        <h1>Mineral Madness</h1>
        <!-- <p style="font-size: 0.85vw; color: red;" id="motcu">"U" before a version means it is unstable and/or unusable, while the number after the "U" tells you what is the current unstable build of that version*</p> -->
        <h3 id="motctitle" style="line-height: 6px; font-size: 16px">MOTC<!-- <divisor style="color: red">U4*</divisor> --> 0.6
        </h3>
        <p id="motctext1" style="line-height: 4px; font-size: 12px">theres now a wiki with these changelogs on the <a href="https://github.com/rubenhdz1213/rubenhdz1213.github.io/wiki/">repository</a></p>
        <p id="motctext2" style="line-height: 4px; font-size: 12px;">use hire to hire up to 3 workers at the cost of 10 coins a minute, they mine 50% to 60% as fast as you and have a chance to get extra returns</p>
        <p id="motctext3" style="font-size: 12px; line-height: 4px;">each worker hired required a down payment of 20 coins</p>
        <p id="motctext4" style="line-height: 4px; font-size: 12px;">0.7 will change biome gen so that distance from the center affects biomes; the far north is 2500 blocks, east is 2500, and vice versa for south and west (transportation will exist too)</p>
        <p id="motctext5" style="line-height: 4px; font-size: 12px">distances above 5k tiles from the center will be the wasteland biome that has no resources but stone</p>
        <!-- <p style="color: red; font-size: 12px; line-height: 1px;" id="motcutext1">recipes command exists</p>
        <p style="color: red; font-size: 12px; line-height: 1px;" id="motcutext2">crafting is fixed but perks from tools dont exist yet</p>
        <p style="color: red; font-size: 12px; line-height: 1px;" id="motcutext3">there is now a cool looking submit button for mobile and stuff as well as a better looking input</p> -->
    </div>
    <div id="console">
        <p id="console1" class="consoletext">></p>
        <p id="console2" class="consoletext">></p>
        <p id="console3" class="consoletext">></p>
        <p id="console4" class="consoletext">></p>
        <p id="console5" class="consoletext">></p>
        <p id="console6" class="consoletext">></p>
        <p id="console7" class="consoletext">></p>
        <p id="console8" class="consoletext">></p>
        <p id="console9" class="consoletext">></p>
        <p id="console10" class="consoletext">></p>
        <p id="console11" class="consoletext">></p>
        <input type="text" id="consoleinput" style=" color: white; border-style: solid; border-color: black;">
        <button id="submit">Submit</button>
    </div>
    <div id="consolee">
        <p id="consolee1" class="consoleetext">></p>
        <p id="consolee2" class="consoleetext">></p>
        <p id="consolee3" class="consoleetext">></p>
        <p id="consolee4" class="consoleetext">></p>
        <p id="consolee5" class="consoleetext">></p>
        <p id="consolee6" class="consoleetext">></p>
        <p id="consolee7" class="consoleetext">></p>
        <p id="consolee8" class="consoleetext">></p>
        <p id="consolee9" class="consoleetext">></p>
        <p id="consolee10" class="consoleetext">></p>
    </div>
    <!-- utility scripts -->
    <div>
        <!-- classes -->
        <script>
            class Vector2 {
                /** @param {Number} x @param {Number} y @param {Number} rotation */
                constructor(x, y, rotation) {
                    this.x = x;
                    this.y = y;
                    this.rotation = rotation % 360;
                }
                /** @param {Vector2[]} vectors */
                static addVectors(vectors) {
                    let sumx = 0;
                    let sumy = 0;
                    let sumr = 0;
                    for (let i = 0; i < vectors.length; i++) {
                        sumx += vectors[i].x;
                        sumy += vectors[i].y;
                        sumr += vectors[i].rotation;
                    }
                    return new Vector2(sumx, sumy, sumr);
                }
                /** @param {Vector2[]} vectors */
                static subtractVectors(vectors) {
                    let diffx = 0;
                    let diffy = 0;
                    let diffr = 0;
                    for (let i = 0; i < vectors.length; i++) {
                        diffx -= vectors[i].x;
                        diffy -= vectors[i].y;
                        diffr -= vectors[i].rotation
                    }
                    return new Vector2(diffx, diffy, diffr);
                }
            }
            class NumberRange {
                /** @param {Number} min @param {Number} max @param {Boolean} inclusiveMin @param {Boolean} invlusiveMax */
                constructor(min, max, inclusiveMin, inclusiveMax) {
                    this.min = min;
                    this.max = max;
                    this.inclusiveMax = inclusiveMax;
                    this.inclusiveMin = inclusiveMin;
                }
                /** @param {Number} number @param {Number} offsetMin @param {Number} offsetMax */
                betweenRange(number, offsetMin = 0, offsetMax = 0) {
                    let withinRange = true;
                    if (this.inclusiveMin) {
                        if (number < this.min + offsetMin) {
                            withinRange = false;
                        }
                    }
                    else {
                        if (number <= this.min + offsetMin) {
                            withinRange = false;
                        }
                    }
                    if (this.inclusiveMax) {
                        if (number > this.max + offsetMin) {
                            withinRange = false;
                        }
                    }
                    else {
                        if (number >= this.max + offsetMin) {
                            withinRange = false;
                        }
                    }
                    return withinRange;
                }
                /** @param {Number} offsetMin @param {Number} offsetMax */
                randomWithinRange(offsetMin, offsetMax) {
                    return randomNumber(this.min + offsetMin, this.max + offsetMax);
                }
            }
            class Item {
                /** @param {Number} itemVolume @param {String} itemName @param {Number} cost */
                constructor(itemVolume, itemName, cost) {
                    this.volume = itemVolume;
                    this.name = itemName;
                    this.sellValue = cost;
                }
                /** @param {Number} amount */
                inventoryPush(amount) {
                    playerData.inventory.addItem(this.name, amount);
                }
            }
            class MapComponent {
                /** @param {Number} x @param {Number} y */
                constructor(x, y) {
                    this.coordinates = new Vector2(x, y);
                }
                /** @param {Number} x @param {Number} y */
                shiftLocation(x, y) {
                    this.coordinates.x += x;
                    this.coordinates.y += y;
                }
            }
            class Material extends Item {
                /** @param {Number} materialVolume @param {String} materialName @param {Number} basePrevalence @param {String[]} biomes @param {Number} cost*/
                constructor(materialVolume, materialName, basePrevalence, biomes = ['all'], cost) {
                    super(materialVolume, materialName, cost);
                    this.basePrevalence = basePrevalence;
                    this.biomes = biomes;
                }
            }
            //materials
            const MATERIALS_1 = [
                new Material(2, 'stone', 2, undefined, 1),
                new Material(1, 'wood', 2, ['plains', 'forest', 'desert', 'mountain', 'savannah', 'tropical forest'], 1),
                new Material(1, 'clay', 1, ['plains', 'forest', 'savannah', 'tropical forest'], 1),
                new Material(1, 'plants', 2, ['plains', 'forest', 'savannah', 'tropical forest'], 1),
                new Material(2, 'obsidian', 1, ['volcano'], 10),
                new Material(1, 'hide', 1, ['plains', 'forest', 'savannah', 'tropical forest'], 2)
            ];
            class CraftableItem extends Item {
                /** @param {Number} itemVolume @param {String} itemName @param {Object[]} costs @param {String} costs[].item @param {Number} costs[].amount @param {Number} multiplier @param {Number} sellValue*/
                constructor(itemVolume, itemName, costs, multiplier = 1, sellValue/*, tier */) {
                    super(itemVolume, itemName, sellValue);
                    this.costs = costs;
                    this.craftMultiplier = multiplier;
                    //this.craftingTier = tier;
                }
            }
            class Tool extends CraftableItem {
                #hasBeenUsed = false;
                /** @param {Number} toolVolume @param {String} toolName @param {Object[]} costs @param {String} costs[].item @param {Number} costs[].amount @param {Object} miningPerks @param {Number} miningPerks.speed @param {Number} miningPerks.returns @param {Number} miningPerks.tier*/
                constructor(toolVolume, toolName, costs, miningPerks, sellValue) {
                    super(toolVolume, toolName, costs, 1, sellValue);
                    this.perks = {
                        mining: miningPerks,
                    }
                }
                perksPush() {
                    this.#hasBeenUsed = true;
                    playerData.perks.mining.returns *= this.perks.mining.returns;
                    playerData.perks.mining.speed *= this.perks.mining.speed;
                    playerData.perks.mining.tier = this.perks.mining.tier > playerData.perks.mining.speed ? this.perks.mining.tier : playerData.perks.mining.tier;
                    playerData.perks.mining.returns = playerData.perks.mining.returns.toPrecision(2);
                    playerData.perks.mining.speed = playerData.perks.mining.speed.toPrecision(2);
                }
                isUsed() {
                    return this.#hasBeenUsed;
                }
            }
            class MapTile extends MapComponent {
                /** @param {Number} x @param {Number} y @param {String} biome @param {Number[]} prevalenceOffset @param {Number} sizeX @param {Number} sizeY */
                constructor(x = 0, y = 0, biome, prevalenceOffset, sizeX = 1, sizeY = 1) {
                    super(x, y);
                    this.biome = biome;
                    /** @type {Object.<string, Number>} */
                    this.prevalences = {}
                    this.sizeX = sizeX;
                    this.sizeY = sizeY;
                    this.building = 'none';
                    this.#offsetInit(prevalenceOffset);
                }
                /** @param {Number[]} offsets */
                #offsetInit(offsets) {
                    for (let i = 0; i < offsets.length; i++) {
                        this.prevalences[MATERIALS_1[i].name] = MATERIALS_1[i].basePrevalence + offsets[i];
                    }
                }
                /** @param {Number} x @param {Number} y */
                static makeCoords(x, y) {
                    return `x${String(x)}y${String(y)}`
                }
            }
            class NaturalBuilding {
                /** @param {String} buildingName @param {Number} spawnChance @param {Number} sizeX @param {Number} sizeY */
                constructor(buildingName, spawnChance, sizeX = 1, sizeY = 1) {
                    this.name = buildingName;
                    this.spawnChance = spawnChance;
                    this.sizeX = sizeX;
                    this.sizeY = sizeY;
                }
                /** @callback spawnCallback @param {MapTile} tile @returns {Boolean} */
                /** @param {spawnCallback} spawnRequirements @param {Number} sizeX @param {Number} sizeY */
                spawn(spawnRequirements, x, y) {
                    const coords = MapTile.makeCoords(x, y);
                    const tile = map[coords];
                    if (Math.random() > this.spawnChance) {
                        return;
                    }
                    if (tile.sizeX < this.sizeX || tile.sizeY < this.sizeY) {
                        return;
                    }
                    if (!spawnRequirements(tile)) {
                        return;
                    }
                    tile.building = this.name;
                }
            }
        </script>
        <!-- functions -->
        <script>
            const EM = {
                /** @param {String} id */
                elementID: function (id) { return document.getElementById(id); },
                /** @param {String} classname */
                elementsClass: function (classname) { return document.getElementsByClassName(classname); },
                /** @param {HTMLElement} element */
                elementText: function (element, text) { element.innerHTML = text; }
            }
            /** @param {String} input */
            function updateText(input, cons = 1) {
                const whichconsole = cons == 1 ? '' : 'e';
                const whichcons = cons == 1 ? '11' : '10';
                for (let i = 1; i < Number(whichcons); i++) {
                    EM.elementID('console' + whichconsole + String(i)).innerHTML = EM.elementID('console' + whichconsole + String(i + 1)).innerHTML;
                }
                EM.elementID('console' + whichconsole + whichcons).innerHTML = '> ' + input;
            }
            /** @param {String} input */
            function updateLine(input, line = 1, cons = 1) {
                const whichconsole = cons == 1 ? '' : 'e';
                EM.elementID('console' + whichconsole + String(line)).innerHTML = '> ' + input;
            }
            /** @typedef {Object} mat @property {String} name @property {Number} amount */
            /** @param {MapTile} tile */
            function mineLocation(mineAmount = 1, tile, multiplier = 1, speed = 1) {
                /** @type {Object.<string, mat>} */
                let materialOutput = {};
                const input = isDigit(mineAmount) ? Number(mineAmount) <= 60 ? Number(mineAmount) : 60 : 1;
                const availableMaterials = MATERIALS_1.filter(value => value.biomes.includes('all') || value.biomes.includes(tile.biome));
                /** @type {Number} total */
                const total = availableMaterials.reduce(/** @param {Number} accumulator */(accumulator, material) => { accumulator = isDigit(accumulator) ? accumulator : 0; return accumulator + tile.prevalences[material.name]; });
                const prevalences = availableMaterials.map(value => tile.prevalences[value.name]);
                for (let i = 0; i < input; i++) {
                    let start = 0;
                    const RN = randomNumber(0, total);
                    availableMaterials.forEach((value, index, arr) => {
                        if (new NumberRange(start, start + prevalences[index], true, index + 1 === arr.length).betweenRange(RN)) {
                            materialOutput[value.name] ??= { name: value.name, amount: 0 };
                            materialOutput[value.name].amount += 1 * multiplier;
                        }
                        start += prevalences[index];
                    });
                }
                const materials = Object.values(materialOutput);
                setTimeout(() => {
                    materials.forEach((material) => {
                        playerData.inventory.addItem(material.name, Math.floor(material.amount));
                    });
                }, (1000 * Number(input)) / speed);
                return materials;
            }
            function doesExist(value) { return value == undefined ? false : true; }
            function randomNumber(min = 0, max = 1) { min = Math.ceil(min); max = Math.floor(max); return Math.round(Math.random() * (max - min) + min); }
            function isDigit(string = '0') {return /^\d+$/.test(string);}
        </script>
        <!-- data storage -->
        <script>
            //error constants
            //playerdata
            //inventory
            const ERROR_NOITEM = -1;
            const ERROR_NOTENOUGHITEM = -2;
            const ERROR_NOTENOUGHSPACE = -3
            // parser constants
            const PARSER_NONE = 0;
            const PARSER_MOVEONMAP = 1;
            const PARSER_MINEAREA = 2;
            const PARSER_CRAFT = 3;
            const PARSER_CRAFTAMOUNT = 4;
            const PARSER_SELL = 5;
            const PARSER_SELLAMOUNT = 6;
            const PARSER_RECIPEBROWSE = 7;
            // secondary parser constants
            const SPARSER_NONE = 0;
            const SPARSER_MINEVILLAGE = 1;
            const SPARSER_MININGVILLAGE = 2;
            //sum summus
            //items
            /** @type {Array.<CraftableItem|Tool>} */
            const ITEMS_1 = [
                new CraftableItem(2, 'wood planks', [{ item: 'wood', amount: 3 }], 1, 4),
                new CraftableItem(1, 'rope', [{ item: 'plants', amount: 3 }], 2, 2),
                new CraftableItem(1, 'flint', [{ item: 'stone', amount: 2 }], 1, 2),
                new CraftableItem(2, 'firewood', [{ item: 'wood planks', amount: 1 }], 1, 6),
                new CraftableItem(1, 'medicinal herbs', [{ item: 'plants', amount: 2 }], 1, 4),
                new CraftableItem(3, 'flint weaponry', [{ item: 'wood', amount: 2 }, { item: 'flint', amount: 2 }, { item: 'rope', amount: 1 }], 1, 12),
                new CraftableItem(6, 'obsidian weaponry', [{ item: 'wood', amount: 2 }, { item: 'obsidian', amount: 2 }, { item: 'rope', amount: 2 }], 1, 30),
                new Tool(5, 'stone tools', [{ item: 'wood', amount: 3 }, { item: 'stone', amount: 4 }, { item: 'rope', amount: 1 }], { returns: 1, speed: 1.2, tier: 0 }, 12),
                new Tool(8, 'obsidian tools', [{ item: 'wood', amount: 3 }, { item: 'obsidian', amount: 2 }, { item: 'rope', amount: 2 }], { returns: 1, speed: 1.5, tier: 1 }, 32),
                new CraftableItem(10, 'survival pack', [{ item: 'stone tools', amount: 1 }, { item: 'flint weaponry', amount: 1 }, { item: 'medicinal herbs', amount: 2 }, { item: 'rope', amount: 3 }], 1, 40),
                new CraftableItem(5, 'firestarting kit', [{ item: 'firewood', amount: 2 }, { item: 'flint', amount: 2 }], 1, 16),
                new CraftableItem(3, 'hide clothes', [{ item: 'hide', amount: 6 }, { item: 'rope', amount: 1 }], 1, 16)
            ];
            //autogenerated buildings
            const STRUCTURES_1 = {
                village: new NaturalBuilding('village', 0.075, 1, 1)
            }
        </script>
    </div>
    <!-- functional scripts -->
    <div>
        <script>
            let playerData = {
                tempStorage: '',
                lastInput: '',
                doingAction: false,
                location: {
                    vector: new Vector2(randomNumber(-99, 99), randomNumber(-99, 99)),
                    getCoords: function () {
                        return `x${String(this.vector.x)}y${String(this.vector.y)}`;
                    }
                },
                materials: {
                    wood: 0,
                    stone: 0,
                    clay: 0
                },
                inventory: {
                    maxvolume: 250,
                    volume: 0,
                    /** @type {Array.<String>} */
                    list: [],
                    /** @type {Array.<Number>} */
                    listamounts: [],
                    /**  @param {String} item */
                    addItem: function (item, amount = 1) {
                        if (this.list.includes(item)) {
                            this.listamounts[this.list.indexOf(item)] += amount;
                        }
                        else {
                            this.list.push(item);
                            this.listamounts.push(amount);
                        }
                    },
                    /** @param {String} item */
                    removeItem: function (item, amount = 1) {
                        if (this.list.includes(item)) {
                            if (this.listamounts[this.list.indexOf(item)] < amount) {
                                return ERROR_NOTENOUGHITEM;
                            }
                            else {
                                if (this.listamounts[this.list.indexOf(item)] - amount == 0) {
                                    this.listamounts.splice(this.list.indexOf(item), 1);
                                    this.list.splice(this.list.indexOf(item), 1);
                                }
                                else {
                                    this.listamounts[this.list.indexOf(item)] -= amount;
                                }
                            }
                        }
                        else {
                            return ERROR_NOITEM;
                        }
                    },
                    /** @param {String} item */
                    getItemAmount: function (item) {
                        return this.list.includes(item) ? this.listamounts[this.list.indexOf(item)] : ERROR_NOITEM;
                    }
                },
                workers: {
                    /** @typedef {Object} Miner @property {Vector2} coords @property {Number} multiplier @property {Number} speed */
                    /** @type {Miner[]} */
                    miners: []
                },
                perks: {
                    mining: {
                        speed: 1,
                        returns: 0,
                        tier: 0
                    }
                }
            }
            let parserKey = PARSER_NONE;
            let secondaryKey = SPARSER_NONE;
            EM.elementID('submit').addEventListener("click", (e) => {
                inputParser(EM.elementID('consoleinput').value);
                EM.elementID('submit').animate([
                    { backgroundColor: '#424242', color: '#ffffff' },
                    { backgroundColor: '#212121', color: '#999999' },
                    { backgroundColor: '#424242', color: '#ffffff' }
                ], {
                    duration: 150,
                    easing: "ease-in"
                })
            })
            EM.elementID('consoleinput').addEventListener("keydown", (e) => {
                if (e.key == 'Enter') {
                    inputParser(e.target.value);
                }
                if (e.key == 'ArrowUp') {
                    e.target.value = playerData.lastInput;
                }
            });
            /**  @param {String} value */
            function inputParser(value) {
                if (playerData.inventory.getItemAmount('coin') >= 250 && playerData.inventory.getItemAmount('pro gamer certificate') == ERROR_NOITEM) {
                    playerData.inventory.addItem('pro gamer certificate');
                    updateText('you got a pro gamer certificate', 2);
                }
                let text = value.toLowerCase();
                playerData.lastInput = text;
                EM.elementID('consoleinput').value = '';
                updateText(text);
                if (text == 'location' && parserKey == PARSER_NONE) {
                    updateText(`you are at x: ${String(playerData.location.vector.x)} y: ${String(playerData.location.vector.y)}`);
                    updateText(`your biome is ${map[`x${String(playerData.location.vector.x)}y${String(playerData.location.vector.y)}`].biome}`);
                }
                if ((text == 'move' && parserKey == PARSER_NONE) || parserKey == PARSER_MOVEONMAP) {
                    if (parserKey == PARSER_MOVEONMAP) {
                        let coords = playerData.location;
                        if (text == 'up') {
                            playerData.location.vector.y += 1;
                            setTimeout(() => {
                                if (map[playerData.location.getCoords()].building == 'village') {
                                    updateText('there is a village on this tile');
                                }
                            }, 101);
                        }
                        else if (text == 'down') {
                            playerData.location.vector.y -= 1;
                            setTimeout(() => {
                                if (map[playerData.location.getCoords()].building == 'village') {
                                    updateText('there is a village on this tile');
                                }
                            }, 101);
                        }
                        else if (text == 'left') {
                            playerData.location.vector.x -= 1;
                            setTimeout(() => {
                                if (map[playerData.location.getCoords()].building == 'village') {
                                    updateText('there is a village on this tile');
                                }
                            }, 101);
                        }
                        else if (text == 'right') {
                            playerData.location.vector.x += 1;
                            setTimeout(() => {
                                if (map[playerData.location.getCoords()].building == 'village') {
                                    updateText('there is a village on this tile');
                                }
                            }, 101);
                        }
                        parserKey = PARSER_NONE;
                    }
                    else {
                        updateText('input direction');
                        parserKey = PARSER_MOVEONMAP;
                    }
                }
                if ((text == 'mine' && parserKey == PARSER_NONE) || parserKey == PARSER_MINEAREA) {
                    const input = isDigit(text) ? Number(text) <= 60 ? Number(text) : 60 : 1;
                    if (!playerData.doingAction) {
                        if (parserKey == PARSER_MINEAREA) {
                            if (secondaryKey === SPARSER_MINEVILLAGE) {
                                secondaryKey = text == 'yes' ?  SPARSER_MININGVILLAGE : SPARSER_NONE;
                                parserKey = text == 'yes' ? PARSER_MINEAREA : PARSER_NONE;
                            }
                            else if (secondaryKey === SPARSER_NONE || secondaryKey === SPARSER_MININGVILLAGE) {
                                let multiplier = 1;
                                if (secondaryKey == SPARSER_MININGVILLAGE) {
                                    const enoughMoney = playerData.inventory.removeItem('coin', Math.ceil(input * 1.25));
                                    multiplier = secondaryKey === SPARSER_MININGVILLAGE && enoughMoney !== ERROR_NOITEM && enoughMoney !== ERROR_NOTENOUGHITEM ? 1.5 : 1;
                                }
                                // /** @type {Object} */
                                EM.elementID('consolee1').innerHTML = '> []';
                                playerData.doingAction = true;
                                function updateProgressBar(progress) {
                                    const progressBarElement = EM.elementID('consolee1');
                                    const progressBarLength = 10;
                                    const progressBarString = "> [" + "-".repeat(progressBarLength * progress) + "]";
                                    progressBarElement.innerHTML = progressBarString;
                                    }
                                    const miningTime = 1000 * input / playerData.perks.mining.speed;
                                    let progress = 0;
                                    playerData.doingAction = true;
                                    const miningInterval = setInterval(() => {
                                    progress += 0.1;
                                    updateProgressBar(progress);
                                    if (progress >= 1) {
                                        clearInterval(miningInterval);
                                        playerData.doingAction = false;
                                        updateProgressBar(1);
                                        EM.elementID('consolee1').innerHTML = '> [Mining Done]';
                                    }
                                    }, miningTime / 10);
                                let inventory = playerData.inventory;
                                const output = mineLocation(text, map[playerData.location.getCoords()], multiplier, playerData.perks.mining.speed);
                                let string = '';
                                output.forEach((value, index, arr) => {string = `${string} ${String(value.amount)} ${value.name}${index + 1 == arr.length && arr.length > 1 ? ', and' : arr.length == 1 ? '' : ', '}`});
                                setTimeout(() => {
                                    updateLine(`you got ${string}`, 2, 2);
                                }, (1000 * Number(input) / playerData.perks.mining.speed) + 1);
                                parserKey = PARSER_NONE;
                            }
                        }
                        else {
                            const build = map[playerData.location.getCoords()].building;
                            updateText(build === 'village' ? 'do you still want to mine, it\'ll cost money for mining in a village but you get more resources' : 'how many times to mine');
                            parserKey = PARSER_MINEAREA;
                            secondaryKey = build === 'village' ? SPARSER_MINEVILLAGE : SPARSER_NONE;
                        }
                    }
                    else {
                        updateText('already doing something');
                    }
                }
                if (text == 'clear' && parserKey == PARSER_NONE) {
                    for (let i = 0; i < 11; i++) {
                        updateText('');
                    }
                }
                if (text == 'inventory' && parserKey == PARSER_NONE) {
                    let string = 'you have ';
                    for (let i = 0; i < playerData.inventory.list.length; i++) {
                        const item = playerData.inventory.list[i];
                        const amount = playerData.inventory.listamounts[i];
                        if (i == playerData.inventory.list.length - 1 && playerData.inventory.list.length >= 3) {
                            string = `${string} ${amount} ${item}`;
                        }
                        else if (i != playerData.inventory.list.length - 1 && playerData.inventory.list.length >= 3) {
                            string = `${string} ${amount} ${item}, `
                        }
                        else if (i == 1 && playerData.inventory.list.length == 2) {
                            string = `${string} and ${amount} ${item}`;
                        }
                        else if (i == 0 && playerData.inventory.list.length == 2) {
                            string = `${string} ${amount} ${item} `;
                        }
                        else if (i == 0 && playerData.inventory.list.length == 1) {
                            string = `${string} ${amount} ${item}`;
                        }
                    }
                    if (playerData.inventory.list.length == 0) {
                        string = 'you have nothing';
                    }
                    updateText(string);
                }
                if ((text == 'craft' && parserKey == PARSER_NONE) || parserKey == PARSER_CRAFT) {
                    if (parserKey == PARSER_CRAFT) {
                        const index = ITEMS_1.findIndex((value) => { return value.name == text });
                        let mats = 0;
                        if (index != -1) {
                            for (let i = 0; i < ITEMS_1[index].costs.length; i++) {
                                const remove = playerData.inventory.removeItem(ITEMS_1[index].costs[i].item, ITEMS_1[index].costs[i].amount);
                                if (remove == ERROR_NOITEM) {
                                    updateText(`you don't have any ${ITEMS_1[index].costs[i].item}, you need ${ITEMS_1[index].costs[i].amount}`);
                                }
                                else if (remove == ERROR_NOTENOUGHITEM) {
                                    updateText(`you don't have enough ${ITEMS_1[index].costs[i].item}, you need ${ITEMS_1[index].costs[i].amount - playerData.inventory.getItemAmount(ITEMS_1[index].costs[i].item)} more`)
                                }
                                else {
                                    mats++;
                                }
                            }
                            if (mats == ITEMS_1[index].costs.length) {
                                playerData.inventory.addItem(ITEMS_1[index].name, ITEMS_1[index].craftMultiplier);
                            }
                            if (typeof ITEMS_1[index].perksPush === "function" && !(ITEMS_1[index].isUsed())) {
                                ITEMS_1[index].perksPush();
                            }
                        }
                        /*
                        costs are an array of objects with the properties item and amount
                        item is the name of the item needed to craft
                        amount is the amount of the item needed to craft
                        */
                        parserKey = PARSER_NONE;
                    }
                    else {
                        updateText('what to craft');
                        parserKey = PARSER_CRAFT;
                    }
                }
                if ((text == 'recipes' && parserKey == PARSER_NONE) || parserKey == PARSER_RECIPEBROWSE) {
                    if (parserKey == PARSER_NONE) {
                        for (let i = 0; i < 9 && i < ITEMS_1.length; i++) {
                            const value = ITEMS_1[i];
                            let string = `${value.name} costs:`
                            value.costs.forEach((valueb, index) => {
                                if (true) {
                                    string = `${string} ${valueb.amount} ${valueb.item}`
                                }
                            })
                            updateText(string);
                            if (i == 8) {
                                playerData.tempStorage = 8;
                                updateText('do you want to go to the next page');
                                parserKey = PARSER_RECIPEBROWSE;
                            }
                        }
                    }
                    else if (parserKey == PARSER_RECIPEBROWSE) {
                        if (text == 'no') {
                            parserKey = PARSER_NONE;
                        }
                        else if (text == 'yes') {
                            for (let i = 0; i < 10 && i + playerData.tempStorage < ITEMS_1.length; i++) {
                                const value = ITEMS_1[i + playerData.tempStorage];
                                let string = `${value.name} costs:`
                                value.costs.forEach((valueb, index) => {
                                    if (true) {
                                        string = `${string} ${valueb.amount} ${valueb.item}`
                                    }
                                })
                                if (i == 9 && i + playerData.tempStorage != ITEMS_1.length - 1) {
                                    playerData.tempStorage += 9;
                                    updateText('do you want to go to the next page');
                                }
                                else if (i + playerData.tempStorage == ITEMS_1.length - 1) {
                                    parserKey = PARSER_NONE;
                                }
                                updateText(string);
                            }
                        }
                    }
                }
                if ((text === 'sell' && parserKey === PARSER_NONE) || parserKey === PARSER_SELL || parserKey === PARSER_SELLAMOUNT) {
                    switch (parserKey) {
                        case PARSER_SELL:
                            if (text === 'cancel') {
                                parserKey = PARSER_NONE;
                            } else {
                                const exists = playerData.inventory.list.includes(text);
                                if (exists) {
                                    playerData.tempStorage = text;
                                    const itemAmount = playerData.inventory.getItemAmount(text);
                                    updateText(`input how many to sell, you have ${itemAmount} ${text}`);
                                    parserKey = PARSER_SELLAMOUNT;
                                }
                                else {
                                    updateText('you don\'t have any of that')
                                }
                                
                            }
                            break;
                        case PARSER_SELLAMOUNT:
                            const mat = MATERIALS_1.find(value => value.name === playerData.tempStorage);
                            const item = ITEMS_1.find(value => value.name === playerData.tempStorage);
                            let amount;
                            if (typeof mat !== 'undefined') {
                                amount = playerData.inventory.getItemAmount(mat.name);
                                const enoughmat = playerData.inventory.removeItem(mat.name, Number(text));
                                if (enoughmat !== ERROR_NOTENOUGHITEM) {
                                playerData.inventory.addItem('coin', mat.sellValue * Number(text));
                                updateText(`you got ${mat.sellValue * Number(text)} coins`);
                                } else {
                                playerData.inventory.addItem('coin', mat.sellValue * amount);
                                updateText(`you got ${mat.sellValue * amount} coins`);
                                playerData.inventory.removeItem(mat.name, amount);
                                }
                            }
                            if (typeof item !== 'undefined') {
                                amount = playerData.inventory.getItemAmount(item.name);
                                const enoughitem = playerData.inventory.removeItem(item.name, Number(text));
                                if (enoughitem !== ERROR_NOTENOUGHITEM) {
                                playerData.inventory.addItem('coin', item.sellValue * Number(text));
                                updateText(`you got ${item.sellValue * Number(text)} coins`);
                                } else {
                                playerData.inventory.addItem('coin', item.sellValue * amount);
                                updateText(`you got ${item.sellValue * amount} coins`);
                                playerData.inventory.removeItem(item.name, amount);
                                }
                            }
                            parserKey = PARSER_NONE;
                        break;
                        default:
                        updateText('input what to sell, or say cancel to cancel');
                        parserKey = PARSER_SELL;
                        break;
                    }
                }
                if (text == 'hire') {
                    const downPayment = playerData.inventory.removeItem('coin', 20);
                    if (downPayment !== ERROR_NOITEM && downPayment !== ERROR_NOTENOUGHITEM) {
                        playerData.workers.miners.length < 3 ? playerData.workers.miners.push({ coords: playerData.location.vector, multiplier: randomNumber (10, 12) / 10, speed: randomNumber(50, 60) / 100 }) : updateText('you can only have 3 workers');
                    }
                    else {
                        updateText('you dont have enough money to pay someone to start working')
                    }
                }
                // if (text == 'tset') {
                //     MATERIALS_1.forEach((value) => {
                //         playerData.inventory.addItem(value.name, 999);
                //     });
                //     ITEMS_1.forEach((value) => {
                //         playerData.inventory.addItem(value.name, 999);
                //     });
                // }

            }
        </script>
        <script>
            /** @type {Object.<string, MapTile>} */
            let map = {};
            {
                let chosen = false;
                setInterval(() => {
                    if (!map.hasOwnProperty(playerData.location.getCoords())) {
                        //eventually use algorithm based on material's stats and what biomes its in to calculate offsets
                        const biomes = [
                            { name: 'plains', prevalenceOffset: [[0, 1], [1, 2], [0, 1], [0, 2], [0, 0], [-1, 0]], likelihood: 3 },
                            { name: 'tundra', prevalenceOffset: [[0, 0], [-1, -1], [0, 0], [-2, -1], [0, 0], [0, 1]], likelihood: 0.5},
                            { name: 'savannah', prevalenceOffset: [[0, 1], [2, 3], [0, 0], [1, 2], [0, 0], [0, 1]], likelihood: 1 },
                            { name: 'tropical forest', prevalenceOffset: [[-2, -1], [3, 5], [-1, 0], [3, 5], [0, 0], [0, 0]], likelihood: 1 },
                            { name: 'forest', prevalenceOffset: [[2, 2], [3, 4], [0, 0], [2, 2], [0, 0], [0, 1]], likelihood: 2 },
                            { name: 'desert', prevalenceOffset: [[0, 0], [-1, 0], [0, 0], [0, 0], [0, 0], [0, 0]], likelihood: 1 },
                            { name: 'mountain', prevalenceOffset: [[2, 3], [-1, -1], [0, 0], [0, 0], [0, 0], [0, 0]], likelihood: 1 },
                            { name: 'volcano', prevalenceOffset: [[14, 15], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]], likelihood: 0.1 },
                        ];
                        const randomBiome = biomes.find(biome => Math.random() < biome.likelihood / 11);
                        const prevalences = function() { let returnArr = []; randomBiome.prevalenceOffset.forEach((value) => { returnArr.push(randomNumber(value[0], value[1])) }); return returnArr }()
                        const name = `x${String(playerData.location.vector.x)}y${String(playerData.location.vector.y)}`;
                        if (!map.hasOwnProperty(playerData.location.getCoords())) {
                            map[name] = new MapTile(playerData.location.vector.x, playerData.location.vector.y, randomBiome.name, prevalences, randomNumber(1, 3), randomNumber(1, 3));
                        }
                        STRUCTURES_1.village.spawn((tile) => {
                            return ['forest', 'plains', 'savannah', 'tropical forest'].includes(tile.biome) && function() { 
                                let canspawn = true;
                                [[-1, 0], [1, 0], [0, -1], [0, 1]].forEach((value) => {
                                    const buildingcheckcoords = MapTile.makeCoords(tile.coordinates.x + value[0], tile.coordinates.y + value[1]); 
                                    if (typeof map[buildingcheckcoords] !== "undefined") {
                                        canspawn = map[buildingcheckcoords].building !== 'none' ? false : canspawn;
                                    }
                                });
                                return canspawn;
                            }();
                            }, playerData.location.vector.x, playerData.location.vector.y);
                        chosen = false;
                    }
                }, 100);
            }  
        </script>
        <script>
            const mineInterval = setInterval(() => {
                let cantPay = 0;
                playerData.workers.miners.forEach((value) => {
                    const canPay = playerData.inventory.removeItem('coin', 10);
                    if (canPay !== ERROR_NOITEM && canPay !== ERROR_NOTENOUGHITEM) {
                        mineLocation(Math.round(60 * value.speed), map[MapTile.makeCoords(value.coords.x, value.coords.y)], value.multiplier)
                    }
                    else {
                        cantPay++;
                    }
                });
                cantPay > 0 ? updateText(`you dont have enough money to pay ${String(cantPay)} of your workers`, 2) : '';
            }, 60000);
        </script>
    </div>
    <footer>
        <b style="font-size: 12px;">rubenhdz1213, ©2023 totally</b>
    </footer>
</body>

</html>