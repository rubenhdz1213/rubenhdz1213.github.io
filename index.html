<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="mining.ico">
    <title>Mineral Madness</title>
</head>

<body>
    <div id="motc">
        <h1>Mineral Madness</h1>
        <!-- <p style="font-size: 0.85vw; color: red;" id="motcu">"U" before a version means it is unstable and/or unusable, while the number after the "U" tells you what is the current unstable build of that version*</p> -->
        <h3 id="motctitle" style="line-height: 6px; font-size: 16px">MOTC <!-- <divisor style="color: red">U4*</divisor> --> 0.3.2.1
        </h3>
        <p id="motctext1" style="line-height: 4px; font-size: 12px">you can get coins from selling things but you cant do anything with those coins</p>
        <p id="motctext2" style="line-height: 4px; font-size: 12px;">0.4 will probably add further refining of materials and items and polish the selling system</p>
        <p id="motctext3" style="font-size: 12px; line-height: 4px;">0.5 will add villages that you cant mine in unless you pay a small fee to mine x times</p>
        <p id="motctext4" style="line-height: 4px; font-size: 12px;">fixed a couple bugs that came from merging development branch</p>
        <!-- <p style="color: red; font-size: 12px; line-height: 1px;" id="motcutext1">recipes command exists</p>
        <p style="color: red; font-size: 12px; line-height: 1px;" id="motcutext2">crafting is fixed but perks from tools dont exist yet</p>
        <p style="color: red; font-size: 12px; line-height: 1px;" id="motcutext3">there is now a cool looking submit button for mobile and stuff as well as a better looking input</p> -->
    </div>
    <div id="console">
        <p id="console1" class="consoletext">></p>
        <p id="console2" class="consoletext">></p>
        <p id="console3" class="consoletext">></p>
        <p id="console4" class="consoletext">></p>
        <p id="console5" class="consoletext">></p>
        <p id="console6" class="consoletext">></p>
        <p id="console7" class="consoletext">></p>
        <p id="console8" class="consoletext">></p>
        <p id="console9" class="consoletext">></p>
        <p id="console10" class="consoletext">></p>
        <p id="console11" class="consoletext">></p>
        <input type="text" id="consoleinput"
            style=" color: white; border-style: solid; border-color: black;">
        <button id="submit">Submit</button>
    </div>
    <div id="consolee">
        <p id="consolee1" class="consoleetext">></p>
        <p id="consolee2" class="consoleetext">></p>
        <p id="consolee3" class="consoleetext">></p>
        <p id="consolee4" class="consoleetext">></p>
        <p id="consolee5" class="consoleetext">></p>
        <p id="consolee6" class="consoleetext">></p>
        <p id="consolee7" class="consoleetext">></p>
        <p id="consolee8" class="consoleetext">></p>
        <p id="consolee9" class="consoleetext">></p>
        <p id="consolee10" class="consoleetext">></p>
    </div>
    <!-- utility scripts -->
    <div>
        <!-- classes -->
        <script>
            class Vector2 {
                /** @param {Number} x @param {Number} y @param {Number} rotation */
                constructor(x, y, rotation) {
                    this.x = x;
                    this.y = y;
                    this.rotation = rotation % 360;
                }
                /** @param {Vector2[]} vectors */
                static addVectors(vectors) {
                    let sumx = 0;
                    let sumy = 0;
                    let sumr = 0;
                    for (let i = 0; i < vectors.length; i++) {
                        sumx += vectors[i].x;
                        sumy += vectors[i].y;
                        sumr += vectors[i].rotation;
                    }
                    return new Vector2(sumx, sumy, sumr);
                }
                /** @param {Vector2[]} vectors */
                static subtractVectors(vectors) {
                    let diffx = 0;
                    let diffy = 0;
                    let diffr = 0;
                    for (let i = 0; i < vectors.length; i++) {
                        diffx -= vectors[i].x;
                        diffy -= vectors[i].y;
                        diffr -= vectors[i].rotation
                    }
                    return new Vector2(diffx, diffy, diffr);
                }
            }
            class NumberRange {
                /** @param {Number} min @param {Number} max */
                constructor(min, max, inclusiveMin, inclusiveMax) {
                    this.min = min;
                    this.max = max;
                    this.inclusiveMax = inclusiveMax;
                    this.inclusiveMin = inclusiveMin;
                }
                /** @param {Number} number @param {Number} offsetMin @param {Number} offsetMax */
                betweenRange(number, offsetMin, offsetMax) {
                    let withinRange = true;
                    if (this.inclusivemin) {
                        if (number < this.min + offsetMin) {
                            withinRange = false;
                        }
                    }
                    else {
                        if (number <= this.min + offsetMin) {
                            withinRange = false;
                        }
                    }
                    if (this.inclusiveMax) {
                        if (number > this.max + offsetMin) {
                            withinRange = false;
                        }
                    }
                    else {
                        if (number >= this.max + offsetMin) {
                            withinRange = false;
                        }
                    }
                }
                /** @param {Number} offsetMin @param {Number} offsetMax */
                randomWithinRange(offsetMin, offsetMax) {
                    return randomNumber(this.min + offsetMin, this.max + offsetMax);
                }
                /** @param {NumberRange} range @param {Number} number @param {Boolean} inclusiveMin @param {Boolean} inclusiveMax    */
                static betweenRange(range, number = 0, inclusiveMin = true, inclusiveMax = true) {
                    let withinRange = true;
                    if (inclusiveMin) {
                        if (number < range.min) {
                            withinRange = false;
                        }
                    }
                    else {
                        if (number <= range.min) {
                            withinRange = false;
                        }
                    }
                    if (inclusiveMax) {
                        if (number > range.max) {
                            withinRange = false;
                        }
                    }
                    else {
                        if (number >= range.max) {
                            withinRange = false;
                        }
                    }
                    return withinRange;
                }
            }
            class Item {
                /** @param {Number} itemVolume @param {String} itemName @param {Number} cost */
                constructor(itemVolume, itemName, cost) {
                    this.volume = itemVolume;
                    this.name = itemName;
                    this.sellValue = cost;
                }
                /** @param {Number} amount */
                inventoryPush(amount) {
                    playerData.inventory.addItem(this.name, amount);
                }
            }
            class MapComponent {
                /** @param {Number} x @param {Number} y */
                constructor(x, y) {
                    this.coordinates = new Vector2(x, y);
                }
                /** @param {Number} x @param {Number} y */
                shiftLocation(x, y) {
                    this.coordinates.x += x;
                    this.coordinates.y += y;
                }
            }
            class Material extends Item {
                /** @param {Number} materialVolume @param {String} materialName @param {Number} basePrevalence @param {String[]} biomes @param {Number} cost*/
                constructor(materialVolume, materialName, basePrevalence, biomes = ['all'], cost) {
                    super(materialVolume, materialName, cost);
                    this.basePrevalence = basePrevalence;
                    this.biomes = biomes;
                }
            }
            //materials
            const MATERIALS_1 = [new Material(2, 'stone', 2, undefined, 1), new Material(1, 'wood', 2, undefined, 1), new Material(1, 'clay', 1, ['plains', 'forest'], 1), new Material(1, 'plants', 2, ['plains', 'forest'], 1)];
            class CraftableItem extends Item {
                /** @param {Number} itemVolume @param {String} itemName @param {Object[]} costs @param {String} costs[].item @param {Number} costs[].amount @param {Number} multiplier @param {Number} sellValue*/
                constructor(itemVolume, itemName, costs, multiplier = 1, sellValue/*, tier */) {
                    super(itemVolume, itemName, sellValue);
                    this.costs = costs;
                    this.craftMultiplier = multiplier;
                    //this.craftingTier = tier;
                }
            }
            class Tool extends CraftableItem {
                #hasBeenUsed = false;
                /** @param {Number} toolVolume @param {String} toolName @param {Object[]} costs @param {String} costs[].item @param {Number} costs[].amount @param {Object} miningPerks @param {Number} miningPerks.speed @param {Number} miningPerks.returns @param {Number} miningPerks.tier*/
                constructor(toolVolume, toolName, costs, miningPerks, sellValue) {
                    super(toolVolume, toolName, costs, sellValue);
                    this.perks = {
                        mining: miningPerks,
                    }
                }
                perksPush() {
                    this.#hasBeenUsed = true;
                    playerData.perks.mining.returns *= this.perks.mining.returns;
                    playerData.perks.mining.speed *= this.perks.mining.speed;
                    playerData.perks.mining.tier = this.perks.mining.tier > playerData.perks.mining.speed ? this.perks.mining.tier : playerData.perks.mining.tier;
                }
                isUsed() {
                    return this.#hasBeenUsed;
                }
            }
            class MapTile extends MapComponent {
                /** @param {Number} x @param {Number} y @param {String} biome @param {Number[]} prevalenceOffset */
                constructor(x = 0, y = 0, biome, prevalenceOffset) {
                    super(x, y);
                    this.biome = biome;
                    /** @type {Object.<string, Number>} */
                    this.prevalences = {}
                    this.#offsetInit(prevalenceOffset);
                }
                /** @param {Number[]} offsets */
                #offsetInit(offsets) {
                    for (let i = 0; i < offsets.length; i++) {
                        this.prevalences[MATERIALS_1[i].name] = MATERIALS_1[i].basePrevalence + offsets[i];
                    }
                }
            }
            class MapBuilding extends MapComponent {
                constructor(x = 0, y = 0, buildingName = 'lorkbench', costItems = ['lorematerial'], costAmounts = [3], tier = 1, materials = ['all']) {
                    super(x, y);
                    this.name = buildingName;
                    this.materials = materials
                    this.tier = tier;
                    this.costItems = costItems;
                    this.costAmounts = costAmounts;
                }
            }
        </script>
        <!-- functions -->
        <script>
            const EM = {
                /** @param {String} id */
                elementID: function (id) { return document.getElementById(id); },
                /** @param {String} classname */
                elementsClass: function (classname) { return document.getElementsByClassName(classname); },
                /** @param {HTMLElement} element */
                elementText: function (element, text) { element.innerHTML = text; }
            }
            function doesExist(value) { return value == undefined ? false : true; }
            function randomNumber(min = 0, max = 1) { min = Math.ceil(min); max = Math.floor(max); return Math.round(Math.random() * (max - min) + min); }
            function isDigit(string = '0') { const digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']; const chars = string.split(''); for (let i = 0; i < chars.length; i++) { const char = chars[i]; if (!digits.includes(char)) { return false; } } return true; }
        </script>
        <!-- data storage -->
        <script>
            //error constants
            //playerdata
            //inventory
            const ERROR_NOITEM = -1;
            const ERROR_NOTENOUGHITEM = -2;
            const ERROR_NOTENOUGHSPACE = -3
            // parser constants
            const PARSER_NONE = 0;
            const PARSER_MOVEONMAP = 1;
            const PARSER_MINEAREA = 2;
            const PARSER_CRAFT = 3;
            const PARSER_SELL = 4;
            const PARSER_SELLAMOUNT = 5;
            //items
            /** @type {Array.<CraftableItem|Tool>} */
            const ITEMS_1 = [new CraftableItem(1, 'wood planks', [{ item: 'wood', amount: 1 }], 2, 1), new CraftableItem(2, 'stone chunks', [{ item: 'stone', amount: 2 }], undefined, 3), new Tool(5, 'stone tools', [{ item: 'stone', amount: 6 }, { item: 'wood', amount: 3 }], { returns: 1, speed: 1.2, tier: 0 }, 12)];
        </script>
    </div>
    <!-- functional scripts -->
    <div>
        <script>
            let playerData = {
                tempStorage: '',
                lastInput: '',
                doingAction: false,
                location: {
                    vector: new Vector2(randomNumber(-99, 99), randomNumber(-99, 99)),
                    getCoords: function () {
                        return `x${String(this.vector.x)}y${String(this.vector.y)}`;
                    }
                },
                materials: {
                    wood: 0,
                    stone: 0,
                    clay: 0
                },
                inventory: {
                    maxvolume: 250,
                    volume: 0,
                    /** @type {Array.<String>} */
                    list: [],
                    /** @type {Array.<Number>} */
                    listamounts: [],
                    /**  @param {String} item */
                    addItem: function (item, amount = 1) {
                        if (this.list.includes(item)) {
                            this.listamounts[this.list.indexOf(item)] += amount;
                        }
                        else {
                            this.list.push(item);
                            this.listamounts.push(amount);
                        }
                    },
                    /** @param {String} item */
                    removeItem: function (item, amount = 1) {
                        if (this.list.includes(item)) {
                            if (this.listamounts[this.list.indexOf(item)] < amount) {
                                return ERROR_NOTENOUGHITEM;
                            }
                            else {
                                if (this.listamounts[this.list.indexOf(item)] - amount == 0) {
                                    this.listamounts.splice(this.list.indexOf(item), 1);
                                    this.list.splice(this.list.indexOf(item), 1);
                                }
                                else {
                                    this.listamounts[this.list.indexOf(item)] -= amount;
                                }
                            }
                        }
                        else {
                            return ERROR_NOITEM;
                        }
                    },
                    /** @param {String} item */
                    getItemAmount: function (item) {
                        return this.list.includes(item) ? this.listamounts[this.list.indexOf(item)] : ERROR_NOITEM;
                    }
                },
                perks: {
                    mining: {
                        speed: 1,
                        returns: 0,
                        tier: 0
                    }
                }
            }
            let parserKey = PARSER_NONE;
            EM.elementID('submit').addEventListener("click", (e) => {
                inputParser(EM.elementID('consoleinput').value);
                EM.elementID('submit').animate([
                    { backgroundColor: '#424242', color: '#ffffff' },
                    { backgroundColor: '#212121', color: '#999999' },
                    { backgroundColor: '#424242', color: '#ffffff' }
                ], {
                    duration: 150,
                    easing: "ease-in"
                })
            })
            EM.elementID('consoleinput').addEventListener("keydown", (e) => {
                if (e.key == 'Enter') {
                    inputParser(e.target.value);
                }
                if (e.key == 'ArrowUp') {
                    e.target.value = playerData.lastInput;
                }
            });
            /**  @param {String} value */
            function inputParser(value) {
                /** @param {String} input */
                function updateText(input, cons = 1) {
                    const whichconsole = cons == 1 ? '' : 'e';
                    for (let i = 1; i < 11; i++) {
                        EM.elementID('console' + whichconsole + String(i)).innerHTML = EM.elementID('console' + String(i + 1)).innerHTML;
                    }
                    EM.elementID('console11').innerHTML = '> ' + input;
                }
                function updateLine(input = 'lorem', line = 1, cons = 1) {
                    const whichconsole = cons == 1 ? '' : 'e';
                    EM.elementID('console' + whichconsole + String(line)).innerHTML = '> ' + input;
                }
                let text = value;
                playerData.lastInput = text;
                EM.elementID('consoleinput').value = '';
                updateText(text);
                if (text == 'location' && parserKey == PARSER_NONE) {
                    updateText(`you are at x: ${String(playerData.location.vector.x)} y: ${String(playerData.location.vector.y)}`);
                    updateText(`your biome is ${map[`x${String(playerData.location.vector.x)}y${String(playerData.location.vector.y)}`].biome}`);
                }
                if ((text == 'move' && parserKey == PARSER_NONE) || parserKey == PARSER_MOVEONMAP) {
                    if (parserKey == PARSER_MOVEONMAP) {
                        let coords = playerData.location;
                        if (text == 'up') {
                            playerData.location.vector.y += 1;
                        }
                        else if (text == 'down') {
                            playerData.location.vector.y -= 1;
                        }
                        else if (text == 'left') {
                            playerData.location.vector.x -= 1;
                        }
                        else if (text == 'right') {
                            playerData.location.vector.x += 1;
                        }
                        parserKey = PARSER_NONE;
                    }
                    else {
                        updateText('input direction');
                        parserKey = PARSER_MOVEONMAP;
                    }
                }
                if ((text == 'mine' && parserKey == PARSER_NONE) || parserKey == PARSER_MINEAREA) {
                    if (!playerData.doingAction) {
                        if (parserKey == PARSER_MINEAREA) {
                            let input = 0;
                            if (!isDigit(text)) {
                                input = 1;
                            }
                            else {
                                input = Math.ceil(Number(text));
                            }
                            if (input > 60) {
                                input = 60;
                            }
                            /** @type {MapTile} */
                            const tile = map[playerData.location.getCoords()];
                            /** @type {String[]} */
                            let materialOutput = [];
                            /** @type {Number[]} */
                            let materialAmount = [];
                            /** @type {String[]} */
                            const locationbiome = tile.biome;
                            let availableMaterials = MATERIALS_1.filter((value) => { return value.biomes.includes('all') || value.biomes.includes(locationbiome) })
                            let total = 0;
                            /** @type {Number[]} */
                            let prevalences = [];
                            for (let i = 0; i < availableMaterials.length; i++) {
                                total += map[playerData.location.getCoords()].prevalences[availableMaterials[i].name];
                                prevalences.push(map[playerData.location.getCoords()].prevalences[availableMaterials[i].name]);
                            }
                            for (let i = 0; i < input; i++) {
                                let start = 0;
                                const RN = randomNumber(0, total);
                                for (let o = 0; o < availableMaterials.length; o++) {
                                    const material = availableMaterials[o];
                                    if (NumberRange.betweenRange(new NumberRange(start, start + prevalences[o]), RN, true, o == availableMaterials.length - 1 ? true : false)) {
                                        if (!materialOutput.includes(material.name)) {
                                            materialOutput.push(material.name);
                                            materialAmount.push(1);
                                        }
                                        else {
                                            materialAmount[materialOutput.indexOf(material.name)] += 1;
                                        }
                                    }
                                    start += prevalences[o];
                                }
                            }
                            /** @type {Object} */
                            EM.elementID('consolee1').innerHTML = '> []';
                            playerData.doingAction = true;
                            setTimeout(() => { EM.elementID('consolee1').innerHTML = '> [-]'; }, 100 * Number(input) / playerData.perks.mining.speed);
                            setTimeout(() => { EM.elementID('consolee1').innerHTML = '> [--]'; }, 200 * Number(input) / playerData.perks.mining.speed);
                            setTimeout(() => { EM.elementID('consolee1').innerHTML = '> [---]'; }, 300 * Number(input) / playerData.perks.mining.speed);
                            setTimeout(() => { EM.elementID('consolee1').innerHTML = '> [----]'; }, 400 * Number(input) / playerData.perks.mining.speed);
                            setTimeout(() => { EM.elementID('consolee1').innerHTML = '> [-----]'; }, 500 * Number(input) / playerData.perks.mining.speed);
                            setTimeout(() => { EM.elementID('consolee1').innerHTML = '> [------]'; }, 600 * Number(input) / playerData.perks.mining.speed);
                            setTimeout(() => { EM.elementID('consolee1').innerHTML = '> [-------]'; }, 700 * Number(input) / playerData.perks.mining.speed);
                            setTimeout(() => { EM.elementID('consolee1').innerHTML = '> [--------]'; }, 800 * Number(input) / playerData.perks.mining.speed);
                            setTimeout(() => { EM.elementID('consolee1').innerHTML = '> [---------]'; }, 900 * Number(input) / playerData.perks.mining.speed);
                            setTimeout(() => { EM.elementID('consolee1').innerHTML = '> [Mining Done]'; playerData.doingAction = false; }, 1000 * Number(input) / playerData.perks.mining.speed);
                            let inventory = playerData.inventory;
                            setTimeout(() => {
                                let string = '';
                                for (let a = 0; a < materialOutput.length; a++) {
                                    string = `${string}${materialAmount[a]} ${materialOutput[a]} `
                                }
                                updateLine(`you got ${string}`, 2, 2);
                                for (let a = 0; a < materialOutput.length; a++) {
                                    const element = materialOutput[a];
                                    const elemen = materialAmount[a];
                                    playerData.inventory.addItem(element, elemen);
                                }
                            }, (1000 * Number(input) / playerData.perks.mining.speed) + 1);
                            parserKey = PARSER_NONE;
                        }
                        else {
                            updateText('how many times to mine');
                            parserKey = PARSER_MINEAREA;
                        }
                    }
                    else {
                        updateText('already doing something');
                    }
                }
                if (text == 'clear' && parserKey == PARSER_NONE) {
                    for (let i = 0; i < 11; i++) {
                        updateText('');
                    }
                }
                if (text == 'inventory' && parserKey == PARSER_NONE) {
                    let string = 'you have ';
                    for (let i = 0; i < playerData.inventory.list.length; i++) {
                        const item = playerData.inventory.list[i];
                        const amount = playerData.inventory.listamounts[i];
                        if (i == playerData.inventory.list.length - 1 && playerData.inventory.list.length >= 3) {
                            string = `${string} ${amount} ${item}`;
                        }
                        else if (i != playerData.inventory.list.length - 1 && playerData.inventory.list.length >= 3) {
                            string = `${string} ${amount} ${item}, `
                        }
                        else if (i == 1 && playerData.inventory.list.length == 2) {
                            string = `${string} and ${amount} ${item}`;
                        }
                        else if (i == 0 && playerData.inventory.list.length == 2) {
                            string = `${string} ${amount} ${item} `;
                        }
                        else if (i == 0 && playerData.inventory.list.length == 1) {
                            string = `${string} ${amount} ${item}`;
                        }
                    }
                    if (playerData.inventory.list.length == 0) {
                        string = 'you have nothing';
                    }
                    updateText(string);
                }
                if ((text == 'craft' && parserKey == PARSER_NONE) || parserKey == PARSER_CRAFT) {
                    if (parserKey == PARSER_CRAFT) {
                        const index = ITEMS_1.findIndex((value) => { return value.name == text });
                        let mats = 0;
                        if (index != -1) {
                            for (let i = 0; i < ITEMS_1[index].costs.length; i++) {
                                const remove = playerData.inventory.removeItem(ITEMS_1[index].costs[i].item, ITEMS_1[index].costs[i].amount);
                                if (remove == ERROR_NOITEM) {
                                    updateText(`you don't have any ${ITEMS_1[index].costs[i].item}, you need ${ITEMS_1[index].costs[i].amount}`);
                                }
                                else if (remove == ERROR_NOTENOUGHITEM) {
                                    updateText(`you don't have enough ${ITEMS_1[index].costs[i].item}, you need ${ITEMS_1[index].costs[i].amount - playerData.inventory.getItemAmount(ITEMS_1[index].costs[i].item)} more`)
                                }
                                else {
                                    mats++;
                                }
                            }
                            if (mats == ITEMS_1[index].costs.length) {
                                playerData.inventory.addItem(ITEMS_1[index].name, ITEMS_1[index].craftMultiplier);
                            }
                            if (typeof ITEMS_1[index].perksPush === "function" && !(ITEMS_1[index].isUsed())) {
                                ITEMS_1[index].perksPush();
                            }
                        }
                        /*
                        costs are an array of objects with the properties item and amount
                        item is the name of the item needed to craft
                        amount is the amount of the item needed to craft
                        */
                        parserKey = PARSER_NONE;
                    }
                    else {
                        updateText('what to craft');
                        parserKey = PARSER_CRAFT;
                    }
                }
                if (text == 'recipes' && parserKey == PARSER_NONE) {
                    ITEMS_1.forEach((value) => {
                        let string = `${value.name} costs:`
                        value.costs.forEach((valueb, index) => {
                            if (true) {
                                string = `${string} ${valueb.amount} ${valueb.item}`
                            } 
                        })
                        updateText(string);
                    });
                }
                if ((text == 'sell' && parserKey == PARSER_NONE) || (parserKey == PARSER_SELL) || (parserKey == PARSER_SELLAMOUNT)) {
                    if (parserKey == PARSER_SELL) {
                        if (text == 'cancel') {
                            parserKey = PARSER_NONE;
                        }
                        else {
                            const exists = playerData.inventory.list.includes(text);
                            if (exists) {
                                playerData.tempStorage = text;
                                updateText(`input how many to sell, you have ${playerData.inventory.getItemAmount(text)} ${text}`)
                            }
                            parserKey = PARSER_SELLAMOUNT;
                        }
                    }
                    else if (parserKey == PARSER_SELLAMOUNT) {
                        const mat = MATERIALS_1.filter((value) => { return value.name == playerData.tempStorage })[0];
                        const item = ITEMS_1.filter((value) => { return value.name == playerData.tempStorage })[0];
                        if (typeof mat !== "undefined" && playerData.inventory.getItemAmount(mat.name)) {
                            const enoughmat = playerData.inventory.removeItem(mat.name, Number(text));
                            if (enoughmat != ERROR_NOTENOUGHITEM) {
                                playerData.inventory.addItem('coin', mat.sellValue * Number(text));
                            }
                            else {
                                playerData.inventory.addItem('coin', mat.sellValue * playerData.inventory.getItemAmount(mat.name));
                            }
                        }
                        if (typeof item !== "undefined" && playerData.inventory.getItemAmount(item.name)) {
                            const enoughitem = playerData.inventory.removeItem(item.name, Number(text));
                            if (enoughitem != ERROR_NOTENOUGHITEM) {
                                playerData.inventory.addItem('coin', item.sellValue * Number(text));
                            }
                            else {
                                playerData.inventory.addItem('coin', item.sellValue * playerData.inventory.getItemAmount(item.name));
                            }
                        }
                        /*
                        costs are an array of objects with the properties item and amount
                        item is the name of the item needed to craft
                        amount is the amount of the item needed to craft
                        */
                        parserKey = PARSER_NONE;
                        
                    }
                    else {
                        updateText('input what to sell, or say cancel to cancel');
                        parserKey = PARSER_SELL;
                    }
                }
                // if (text == 'tset') {
                //     MATERIALS_1.forEach((value) => {
                //         playerData.inventory.addItem(value.name, 999)
                //     });
                // }

            }
        </script>
        <script>
            /** @type {Object.<string, MapTile>} */
            let map = {};
            {
                let chosen = false;
                setInterval(() => {
                    if (!map.hasOwnProperty(playerData.location.getCoords())) {
                        let prevalenceOffset = [];
                        let biome = '';
                        const number = randomNumber(1, 5);
                        chosen = true;
                        if (chosen) {
                            switch (number) {
                                /*a prevalence value divided by the sum of all 3 prevalence values times 
                                100 is about how many of a material you get per 100 resources */
                                case 1:
                                    prevalenceOffset = [[1, 2], [-1, 0], [0, 1], [0, 1]];
                                    biome = 'plains';
                                    break;
                                case 2:
                                    prevalenceOffset = [[1, 2], [1, 1], [0, 1], [1, 2]];
                                    biome = 'plains';
                                    break;
                                case 3:
                                    prevalenceOffset = [[0, 0], [-1, 0], [0, 0], [0, 0]];
                                    biome = 'desert';
                                    break;
                                case 4:
                                    prevalenceOffset = [[1, 1], [2, 3], [0, 0], [2, 2]];
                                    biome = 'forest';
                                    break;
                                case 5:
                                    prevalenceOffset = [[2, 3], [-1, -1], [0, 0], [0, 0]];
                                    biome = 'mountain';
                                    break;
                            }
                        }
                        let name = `x${String(playerData.location.vector.x)}y${String(playerData.location.vector.y)}`;
                        if (!map.hasOwnProperty(playerData.location.getCoords())) {
                            map[name] = new MapTile(playerData.location.vector.x, playerData.location.vector.y, biome, [randomNumber(prevalenceOffset[0][0], prevalenceOffset[0][1]), randomNumber(prevalenceOffset[1][0], prevalenceOffset[1][1]), randomNumber(prevalenceOffset[2][0], prevalenceOffset[2][1]), randomNumber(prevalenceOffset[3][0], prevalenceOffset[3][1])]);
                        }
                        chosen = false;
                    }
                }, 100);
            }  
        </script>
    </div>
    <footer>
        <b>haha</b>
    </footer>
</body>

</html>